

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>spack package &mdash; Spack 1.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'./',
        VERSION:'1.0',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="Spack 1.0 documentation" href="index.html"/>
        <link rel="next" title="spack.cmd package" href="spack.cmd.html"/>
        <link rel="prev" title="Package List" href="package_list.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="icon icon-home"> Spack</a>
        <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Feature Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="features.html#simple-package-installation">Simple package installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#custom-versions-configurations">Custom versions &amp; configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#customize-dependencies">Customize dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#non-destructive-installs">Non-destructive installs</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#packages-can-peacefully-coexist">Packages can peacefully coexist</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#creating-packages-is-easy">Creating packages is easy</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#download">Download</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#install">Install</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="basic_usage.html">Basic usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#getting-help">Getting Help</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#listing-available-packages">Listing available packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#compiler-configuration">Compiler Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#installing-and-uninstalling">Installing and uninstalling</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#specs-dependencies">Specs &amp; Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#virtual-dependencies">Virtual dependencies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="packaging_guide.html">Packaging Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#package-files">Package Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#creating-packages">Creating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#virtual-dependencies">Virtual dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#abstract-concrete-specs">Abstract &amp; concrete specs</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#install-environment">Install environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#patches">Patches</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#implementing-the-install-method">Implementing the <tt class="docutils literal"><span class="pre">install</span></tt> method</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#prefix-objects">Prefix objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#spec-objects">Spec objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#shell-command-wrappers">Shell command wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#the-package-build-process">The package build process</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="site_configuration.html">Site-specific configuration</a><ul>
<li class="toctree-l2"><a class="reference internal" href="site_configuration.html#mirrors">Mirrors</a></li>
<li class="toctree-l2"><a class="reference internal" href="site_configuration.html#temporary-space">Temporary space</a></li>
<li class="toctree-l2"><a class="reference internal" href="site_configuration.html#concretization-policies">Concretization policies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="developer_guide.html">Developer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#directory-structure">Directory Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#code-structure">Code Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#spec-objects">Spec objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#package-objects">Package objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#stage-objects">Stage objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#writing-commands">Writing commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#id3">Unit tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#unit-testing">Unit testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#developer-commands">Developer commands</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="package_list.html">Package List</a><ul>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#adept-utils">adept-utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#automaded">automaded</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#boost">boost</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#callpath">callpath</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#clang">clang</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#cmake">cmake</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#cube">cube</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#dtcmp">dtcmp</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#dyninst">dyninst</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#extrae">extrae</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#graphlib">graphlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#hdf5">hdf5</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#hwloc">hwloc</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#launchmon">launchmon</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#libarchive">libarchive</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#libcircle">libcircle</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#libdwarf">libdwarf</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#libelf">libelf</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#libevent">libevent</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#libmonitor">libmonitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#libnbc">libNBC</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#libunwind">libunwind</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#llvm">llvm</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#llvm-lld">llvm-lld</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#lwgrp">lwgrp</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#mpich">mpich</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#mpileaks">mpileaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#mrnet">mrnet</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#mvapich2">mvapich2</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#ncurses">ncurses</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#netgauge">netgauge</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#ompss">ompss</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#opari2">opari2</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#openmpi">openmpi</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#openssl">openssl</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#otf2">otf2</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#papi">papi</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#paraver">paraver</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#parmetis">parmetis</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#pmgr-collective">pmgr_collective</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#postgresql">postgresql</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#samrai">SAMRAI</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#scalasca">scalasca</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#scorep">scorep</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#scr">scr</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#spindle">spindle</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#sqlite">sqlite</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#stat">stat</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#sundials">sundials</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#swig">swig</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#tau">tau</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#tmux">tmux</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#vim">vim</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#wx">wx</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#wxpropgrid">wxpropgrid</a></li>
<li class="toctree-l2"><a class="reference internal" href="package_list.html#zlib">zlib</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">API Docs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.architecture">spack.architecture module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.build_environment">spack.build_environment module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.compilation">spack.compilation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.compiler">spack.compiler module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.concretize">spack.concretize module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.config">spack.config module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.directory_layout">spack.directory_layout module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.error">spack.error module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.mirror">spack.mirror module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.modules">spack.modules module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.multimethod">spack.multimethod module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.package">spack.package module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.packages">spack.packages module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.parse">spack.parse module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.patch">spack.patch module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.relations">spack.relations module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.spec">spack.spec module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.stage">spack.stage module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.url">spack.url module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.version">spack.version module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.virtual">spack.virtual module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack">Module contents</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="index.html">Spack</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="index.html">Docs</a> &raquo;</li>
  <li><a href="">spack package</a></li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="_sources/spack.txt" rel="nofollow"> View page source</a>
      
    </li>
</ul>
<hr/>

          
  <div class="section" id="spack-package">
<h1>spack package<a class="headerlink" href="#spack-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="spack.cmd.html">spack.cmd package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.arch">spack.cmd.arch module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.bootstrap">spack.cmd.bootstrap module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.cd">spack.cmd.cd module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.checksum">spack.cmd.checksum module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.clean">spack.cmd.clean module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.compiler">spack.cmd.compiler module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.compilers">spack.cmd.compilers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.config">spack.cmd.config module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.create">spack.cmd.create module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.dependents">spack.cmd.dependents module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.doc">spack.cmd.doc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.edit">spack.cmd.edit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.fetch">spack.cmd.fetch module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.find">spack.cmd.find module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.graph">spack.cmd.graph module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.help">spack.cmd.help module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.info">spack.cmd.info module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.install">spack.cmd.install module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.list">spack.cmd.list module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.load">spack.cmd.load module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.location">spack.cmd.location module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.mirror">spack.cmd.mirror module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.module">spack.cmd.module module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.patch">spack.cmd.patch module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.pkg">spack.cmd.pkg module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.providers">spack.cmd.providers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.purge">spack.cmd.purge module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.python">spack.cmd.python module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.spec">spack.cmd.spec module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.stage">spack.cmd.stage module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.test">spack.cmd.test module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.uninstall">spack.cmd.uninstall module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.unload">spack.cmd.unload module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.unuse">spack.cmd.unuse module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.use">spack.cmd.use module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.versions">spack.cmd.versions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spack.compilers.html">spack.compilers package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spack.compilers.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.compilers.html#module-spack.compilers.clang">spack.compilers.clang module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.compilers.html#module-spack.compilers.gcc">spack.compilers.gcc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.compilers.html#module-spack.compilers.intel">spack.compilers.intel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.compilers.html#module-spack.compilers.pgi">spack.compilers.pgi module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.compilers.html#module-spack.compilers">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spack.hooks.html">spack.hooks package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spack.hooks.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.hooks.html#module-spack.hooks.dotkit">spack.hooks.dotkit module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.hooks.html#module-spack.hooks.tclmodule">spack.hooks.tclmodule module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.hooks.html#module-spack.hooks">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spack.test.html">spack.test package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.concretize">spack.test.concretize module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.config">spack.test.config module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.directory_layout">spack.test.directory_layout module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.install">spack.test.install module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.mock_packages_test">spack.test.mock_packages_test module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.multimethod">spack.test.multimethod module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.package_sanity">spack.test.package_sanity module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.packages">spack.test.packages module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.python_version">spack.test.python_version module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.spec_dag">spack.test.spec_dag module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.spec_semantics">spack.test.spec_semantics module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.spec_syntax">spack.test.spec_syntax module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.stage">spack.test.stage module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.url_parse">spack.test.url_parse module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.url_substitution">spack.test.url_substitution module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.versions">spack.test.versions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spack.util.html">spack.util package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.compression">spack.util.compression module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.crypto">spack.util.crypto module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.environment">spack.util.environment module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.executable">spack.util.executable module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.multiproc">spack.util.multiproc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.naming">spack.util.naming module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.prefix">spack.util.prefix module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.string">spack.util.string module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.web">spack.util.web module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-spack.architecture">
<span id="spack-architecture-module"></span><h2>spack.architecture module<a class="headerlink" href="#module-spack.architecture" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="spack.architecture.InvalidSysTypeError">
<em class="property">exception </em><tt class="descclassname">spack.architecture.</tt><tt class="descname">InvalidSysTypeError</tt><big>(</big><em>sys_type</em><big>)</big><a class="headerlink" href="#spack.architecture.InvalidSysTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
</dd></dl>

<dl class="exception">
<dt id="spack.architecture.NoSysTypeError">
<em class="property">exception </em><tt class="descclassname">spack.architecture.</tt><tt class="descname">NoSysTypeError</tt><a class="headerlink" href="#spack.architecture.NoSysTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="spack.architecture.get_mac_sys_type">
<tt class="descclassname">spack.architecture.</tt><tt class="descname">get_mac_sys_type</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.architecture.get_mac_sys_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mac OS SYS_TYPE or None if this isn&#8217;t a mac.</p>
</dd></dl>

<dl class="function">
<dt id="spack.architecture.get_sys_type_from_environment">
<tt class="descclassname">spack.architecture.</tt><tt class="descname">get_sys_type_from_environment</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.architecture.get_sys_type_from_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return $SYS_TYPE or None if it&#8217;s not defined.</p>
</dd></dl>

<dl class="function">
<dt id="spack.architecture.get_sys_type_from_spack_globals">
<tt class="descclassname">spack.architecture.</tt><tt class="descname">get_sys_type_from_spack_globals</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.architecture.get_sys_type_from_spack_globals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the SYS_TYPE from spack globals, or None if it isn&#8217;t set.</p>
</dd></dl>

<dl class="function">
<dt id="spack.architecture.sys_type">
<tt class="descclassname">spack.architecture.</tt><tt class="descname">sys_type</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.architecture.sys_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SysType for the current machine.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.build_environment">
<span id="spack-build-environment-module"></span><h2>spack.build_environment module<a class="headerlink" href="#module-spack.build_environment" title="Permalink to this headline">¶</a></h2>
<p>This module contains all routines related to setting up the package
build environment.  All of this is set up by package.py just before
install() is called.</p>
<p>There are two parts to the bulid environment:</p>
<ol class="arabic">
<li><p class="first">Python build environment (i.e. install() method)</p>
<p>This is how things are set up when install() is called.  Spack
takes advantage of each package being in its own module by adding a
bunch of command-like functions (like configure(), make(), etc.) in
the package&#8217;s module scope.  Ths allows package writers to call
them all directly in Package.install() without writing &#8216;self.&#8217;
everywhere.  No, this isn&#8217;t Pythonic.  Yes, it makes the code more
readable and more like the shell script from whcih someone is
likely porting.</p>
</li>
<li><p class="first">Build execution environment</p>
<p>This is the set of environment variables, like PATH, CC, CXX,
etc. that control the build.  There are also a number of
environment variables used to pass information (like RPATHs and
other information about dependencies) to Spack&#8217;s compiler wrappers.
All of these env vars are also set up here.</p>
</li>
</ol>
<p>Skimming this module is a nice way to get acquainted with the types of
calls you can make from within the install() function.</p>
<dl class="class">
<dt id="spack.build_environment.MakeExecutable">
<em class="property">class </em><tt class="descclassname">spack.build_environment.</tt><tt class="descname">MakeExecutable</tt><big>(</big><em>name</em>, <em>parallel</em><big>)</big><a class="headerlink" href="#spack.build_environment.MakeExecutable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="spack.util.html#spack.util.executable.Executable" title="spack.util.executable.Executable"><tt class="xref py py-class docutils literal"><span class="pre">spack.util.executable.Executable</span></tt></a></p>
<p>Special callable executable object for make so the user can
specify parallel or not on a per-invocation basis.  Using
&#8216;parallel&#8217; as a kwarg will override whatever the package&#8217;s
global setting is, so you can either default to true or false
and override particular calls.</p>
<p>Note that if the SPACK_NO_PARALLEL_MAKE env var is set it overrides
everything.</p>
</dd></dl>

<dl class="function">
<dt id="spack.build_environment.set_build_environment_variables">
<tt class="descclassname">spack.build_environment.</tt><tt class="descname">set_build_environment_variables</tt><big>(</big><em>pkg</em><big>)</big><a class="headerlink" href="#spack.build_environment.set_build_environment_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>This ensures a clean install environment when we build packages.</p>
</dd></dl>

<dl class="function">
<dt id="spack.build_environment.set_compiler_environment_variables">
<tt class="descclassname">spack.build_environment.</tt><tt class="descname">set_compiler_environment_variables</tt><big>(</big><em>pkg</em><big>)</big><a class="headerlink" href="#spack.build_environment.set_compiler_environment_variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.build_environment.set_module_variables_for_package">
<tt class="descclassname">spack.build_environment.</tt><tt class="descname">set_module_variables_for_package</tt><big>(</big><em>pkg</em><big>)</big><a class="headerlink" href="#spack.build_environment.set_module_variables_for_package" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate the module scope of install() with some useful functions.
This makes things easier for package writers.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.compilation">
<span id="spack-compilation-module"></span><h2>spack.compilation module<a class="headerlink" href="#module-spack.compilation" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">compilation</span></tt> module contains utility functions used by the compiler
wrapper script.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Think about moving this into the script to increase compilation
speed.</p>
</div>
<dl class="function">
<dt id="spack.compilation.get_env_flag">
<tt class="descclassname">spack.compilation.</tt><tt class="descname">get_env_flag</tt><big>(</big><em>name</em>, <em>required=False</em><big>)</big><a class="headerlink" href="#spack.compilation.get_env_flag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.compilation.get_env_var">
<tt class="descclassname">spack.compilation.</tt><tt class="descname">get_env_var</tt><big>(</big><em>name</em>, <em>required=True</em><big>)</big><a class="headerlink" href="#spack.compilation.get_env_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.compilation.get_path">
<tt class="descclassname">spack.compilation.</tt><tt class="descname">get_path</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#spack.compilation.get_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.compilation.parse_rpaths">
<tt class="descclassname">spack.compilation.</tt><tt class="descname">parse_rpaths</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#spack.compilation.parse_rpaths" title="Permalink to this definition">¶</a></dt>
<dd><p>argparse, for all its features, cannot understand most compilers&#8217;
rpath arguments.  This handles &#8216;-Wl,&#8217;, &#8216;-Xlinker&#8217;, and &#8216;-R&#8217;</p>
</dd></dl>

</div>
<div class="section" id="module-spack.compiler">
<span id="spack-compiler-module"></span><h2>spack.compiler module<a class="headerlink" href="#module-spack.compiler" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="spack.compiler.Compiler">
<em class="property">class </em><tt class="descclassname">spack.compiler.</tt><tt class="descname">Compiler</tt><big>(</big><em>cspec</em>, <em>cc</em>, <em>cxx</em>, <em>f77</em>, <em>fc</em><big>)</big><a class="headerlink" href="#spack.compiler.Compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class encapsulates a Spack &#8220;compiler&#8221;, which includes C,
C++, and Fortran compilers.  Subclasses should implement
support for specific compilers, their possible names, arguments,
and how to identify the particular type of compiler.</p>
<dl class="attribute">
<dt id="spack.compiler.Compiler.arg_rpath">
<tt class="descname">arg_rpath</tt><em class="property"> = '-Wl,-rpath,%s'</em><a class="headerlink" href="#spack.compiler.Compiler.arg_rpath" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.compiler.Compiler.cc_names">
<tt class="descname">cc_names</tt><em class="property"> = []</em><a class="headerlink" href="#spack.compiler.Compiler.cc_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="spack.compiler.Compiler.cc_version">
<em class="property">classmethod </em><tt class="descname">cc_version</tt><big>(</big><em>cc</em><big>)</big><a class="headerlink" href="#spack.compiler.Compiler.cc_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.compiler.Compiler.cxx11_flag">
<tt class="descname">cxx11_flag</tt><em class="property"> = '-std=c++11'</em><a class="headerlink" href="#spack.compiler.Compiler.cxx11_flag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.compiler.Compiler.cxx_names">
<tt class="descname">cxx_names</tt><em class="property"> = []</em><a class="headerlink" href="#spack.compiler.Compiler.cxx_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="spack.compiler.Compiler.cxx_version">
<em class="property">classmethod </em><tt class="descname">cxx_version</tt><big>(</big><em>cxx</em><big>)</big><a class="headerlink" href="#spack.compiler.Compiler.cxx_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="spack.compiler.Compiler.default_version">
<em class="property">classmethod </em><tt class="descname">default_version</tt><big>(</big><em>cc</em><big>)</big><a class="headerlink" href="#spack.compiler.Compiler.default_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Override just this to override all compiler version functions.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.compiler.Compiler.f77_names">
<tt class="descname">f77_names</tt><em class="property"> = []</em><a class="headerlink" href="#spack.compiler.Compiler.f77_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="spack.compiler.Compiler.f77_version">
<em class="property">classmethod </em><tt class="descname">f77_version</tt><big>(</big><em>f77</em><big>)</big><a class="headerlink" href="#spack.compiler.Compiler.f77_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.compiler.Compiler.fc_names">
<tt class="descname">fc_names</tt><em class="property"> = []</em><a class="headerlink" href="#spack.compiler.Compiler.fc_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="spack.compiler.Compiler.fc_version">
<em class="property">classmethod </em><tt class="descname">fc_version</tt><big>(</big><em>fc</em><big>)</big><a class="headerlink" href="#spack.compiler.Compiler.fc_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="spack.compiler.Compiler.find">
<em class="property">classmethod </em><tt class="descname">find</tt><big>(</big><em>*path</em><big>)</big><a class="headerlink" href="#spack.compiler.Compiler.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to find this type of compiler in the user&#8217;s
environment. For each set of compilers found, this returns
compiler objects with the cc, cxx, f77, fc paths and the
version filled in.</p>
<p>This will search for compilers with the names in cc_names,
cxx_names, etc. and it will group them if they have common
prefixes, suffixes, and versions.  e.g., gcc-mp-4.7 would
be grouped with g++-mp-4.7 and gfortran-mp-4.7.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.compiler.Compiler.prefixes">
<tt class="descname">prefixes</tt><em class="property"> = []</em><a class="headerlink" href="#spack.compiler.Compiler.prefixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.compiler.Compiler.suffixes">
<tt class="descname">suffixes</tt><em class="property"> = ['-.*']</em><a class="headerlink" href="#spack.compiler.Compiler.suffixes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.compiler.Compiler.version">
<tt class="descname">version</tt><a class="headerlink" href="#spack.compiler.Compiler.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.compiler.get_compiler_version">
<tt class="descclassname">spack.compiler.</tt><tt class="descname">get_compiler_version</tt><big>(</big><em>compiler_path</em>, <em>version_arg</em>, <em>regex='(.*)'</em><big>)</big><a class="headerlink" href="#spack.compiler.get_compiler_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-spack.concretize">
<span id="spack-concretize-module"></span><h2>spack.concretize module<a class="headerlink" href="#module-spack.concretize" title="Permalink to this headline">¶</a></h2>
<p>Functions here are used to take abstract specs and make them concrete.
For example, if a spec asks for a version between 1.8 and 1.9, these
functions might take will take the most recent 1.9 version of the
package available.  Or, if the user didn&#8217;t specify a compiler for a
spec, then this will assign a compiler to the spec based on defaults
or user preferences.</p>
<dl class="docutils">
<dt>TODO: make this customizable and allow users to configure</dt>
<dd>concretization  policies.</dd>
</dl>
<dl class="class">
<dt id="spack.concretize.DefaultConcretizer">
<em class="property">class </em><tt class="descclassname">spack.concretize.</tt><tt class="descname">DefaultConcretizer</tt><a class="headerlink" href="#spack.concretize.DefaultConcretizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class doesn&#8217;t have any state, it just provides some methods for
concretization.  You can subclass it to override just some of the
default concretization strategies, or you can override all of them.</p>
<dl class="method">
<dt id="spack.concretize.DefaultConcretizer.choose_provider">
<tt class="descname">choose_provider</tt><big>(</big><em>spec</em>, <em>providers</em><big>)</big><a class="headerlink" href="#spack.concretize.DefaultConcretizer.choose_provider" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked for virtual specs.  Given a spec with a virtual name,
say &#8220;mpi&#8221;, and a list of specs of possible providers of that spec,
select a provider and return it.</p>
</dd></dl>

<dl class="method">
<dt id="spack.concretize.DefaultConcretizer.concretize_architecture">
<tt class="descname">concretize_architecture</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.concretize.DefaultConcretizer.concretize_architecture" title="Permalink to this definition">¶</a></dt>
<dd><p>If the spec already had an architecture, return.  Otherwise if
the root of the DAG has an architecture, then use that.
Otherwise take the system&#8217;s default architecture.</p>
<p>Intuition: Architectures won&#8217;t be set a lot, and generally you
want the host system&#8217;s architecture.  When architectures are
mised in a spec, it is likely because the tool requries a
cross-compiled component, e.g. for tools that run on BlueGene
or Cray machines.  These constraints will likely come directly
from packages, so require the user to be explicit if they want
to mess with the architecture, and revert to the default when
they&#8217;re not explicit.</p>
</dd></dl>

<dl class="method">
<dt id="spack.concretize.DefaultConcretizer.concretize_compiler">
<tt class="descname">concretize_compiler</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.concretize.DefaultConcretizer.concretize_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>If the spec already has a compiler, we&#8217;re done.  If not, then take
the compiler used for the nearest ancestor with a compiler
spec and use that.  If the ancestor&#8217;s compiler is not
concrete, then give it a valid version.  If there is no
ancestor with a compiler, use the system default compiler.</p>
<p>Intuition: Use the system default if no package that depends on
this one has a strict compiler requirement.  Otherwise, try to
build with the compiler that will be used by libraries that
link to this one, to maximize compatibility.</p>
</dd></dl>

<dl class="method">
<dt id="spack.concretize.DefaultConcretizer.concretize_version">
<tt class="descname">concretize_version</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.concretize.DefaultConcretizer.concretize_version" title="Permalink to this definition">¶</a></dt>
<dd><p>If the spec is already concrete, return.  Otherwise take
the most recent available version, and default to the package&#8217;s
version if there are no avaialble versions.</p>
<dl class="docutils">
<dt>TODO: In many cases we probably want to look for installed</dt>
<dd>versions of each package and use an installed version
if we can link to it.  The policy implemented here will
tend to rebuild a lot of stuff becasue it will prefer
a compiler in the spec to any compiler already-
installed things were built with.  There is likely
some better policy that finds some middle ground
between these two extremes.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.concretize.NoValidVerionError">
<em class="property">exception </em><tt class="descclassname">spack.concretize.</tt><tt class="descname">NoValidVerionError</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.concretize.NoValidVerionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when there is no available version for a package that
satisfies a spec.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.concretize.UnavailableCompilerVersionError">
<em class="property">exception </em><tt class="descclassname">spack.concretize.</tt><tt class="descname">UnavailableCompilerVersionError</tt><big>(</big><em>compiler_spec</em><big>)</big><a class="headerlink" href="#spack.concretize.UnavailableCompilerVersionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when there is no available compiler that satisfies a
compiler spec.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.config">
<span id="spack-config-module"></span><h2>spack.config module<a class="headerlink" href="#module-spack.config" title="Permalink to this headline">¶</a></h2>
<p>This module implements Spack&#8217;s configuration file handling.</p>
<div class="section" id="configuration-file-scopes">
<h3>Configuration file scopes<a class="headerlink" href="#configuration-file-scopes" title="Permalink to this headline">¶</a></h3>
<p>When Spack runs, it pulls configuration data from several config
files, much like bash shells.  In Spack, there are two configuration
scopes:</p>
<blockquote>
<div><ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">site</span></tt>: Spack loads site-wide configuration options from</li>
</ol>
<blockquote>
<div><tt class="docutils literal"><span class="pre">$(prefix)/etc/spackconfig</span></tt>.</div></blockquote>
<ol class="arabic simple" start="2">
<li><tt class="docutils literal"><span class="pre">user</span></tt>: Spack next loads per-user configuration options from
~/.spackconfig.</li>
</ol>
</div></blockquote>
<p>If user options have the same names as site options, the user options
take precedence.</p>
</div>
<div class="section" id="configuration-file-format">
<h3>Configuration file format<a class="headerlink" href="#configuration-file-format" title="Permalink to this headline">¶</a></h3>
<p>Configuration files are formatted using .gitconfig syntax, which is
much like Windows .INI format.  This format is implemented by Python&#8217;s
ConfigParser class, and it&#8217;s easy to read and versatile.</p>
<p>The file is divided into sections, like this <tt class="docutils literal"><span class="pre">compiler</span></tt> section:</p>
<div class="highlight-python"><div class="highlight"><pre>[compiler]
    cc = /usr/bin/gcc
</pre></div>
</div>
<p>In each section there are options (cc), and each option has a value
(/usr/bin/gcc).</p>
<p>Borrowing from git, we also allow named sections, e.g.:</p>
<blockquote>
<div><dl class="docutils">
<dt>[compiler &#8220;<a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;7&#46;3">gcc<span>&#64;</span>4<span>&#46;</span>7<span>&#46;</span>3</a>&#8220;]</dt>
<dd>cc = /usr/bin/gcc</dd>
</dl>
</div></blockquote>
<p>This is a compiler section, but it&#8217;s for the specific compiler,
<tt class="docutils literal"><span class="pre">gcc&#64;4.7.3</span></tt>.  <tt class="docutils literal"><span class="pre">gcc&#64;4.7.3</span></tt> is the name.</p>
</div>
<div class="section" id="keys">
<h3>Keys<a class="headerlink" href="#keys" title="Permalink to this headline">¶</a></h3>
<p>Together, the section, name, and option, separated by periods, are
called a <tt class="docutils literal"><span class="pre">key</span></tt>.  Keys can be used on the command line to set
configuration options explicitly (this is also borrowed from git).</p>
<p>For example, to change the C compiler used by <a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;7&#46;3">gcc<span>&#64;</span>4<span>&#46;</span>7<span>&#46;</span>3</a>, you could do
this:</p>
<blockquote>
<div>spack config <a class="reference external" href="mailto:compiler&#46;gcc&#37;&#52;&#48;4&#46;7&#46;3&#46;cc">compiler<span>&#46;</span>gcc<span>&#64;</span>4<span>&#46;</span>7<span>&#46;</span>3<span>&#46;</span>cc</a> /usr/local/bin/gcc</div></blockquote>
<p>That will create a named compiler section in the user&#8217;s .spackconfig
like the one shown above.</p>
<dl class="class">
<dt id="spack.config.SpackConfigParser">
<em class="property">class </em><tt class="descclassname">spack.config.</tt><tt class="descname">SpackConfigParser</tt><big>(</big><em>file_or_files</em><big>)</big><a class="headerlink" href="#spack.config.SpackConfigParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">ConfigParser.RawConfigParser</span></tt></p>
<p>Slightly modified from Python&#8217;s raw config file parser to accept
leading whitespace and preserve comments.</p>
<dl class="attribute">
<dt id="spack.config.SpackConfigParser.OPTCRE">
<tt class="descname">OPTCRE</tt><em class="property"> = &lt;_sre.SRE_Pattern object at 0x10ee6f6f0&gt;</em><a class="headerlink" href="#spack.config.SpackConfigParser.OPTCRE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.config.SpackConfigParser.get_section_names">
<tt class="descname">get_section_names</tt><big>(</big><em>sectype</em><big>)</big><a class="headerlink" href="#spack.config.SpackConfigParser.get_section_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all named sections with the specified type.
A named section looks like this:</p>
<blockquote>
<div>[compiler &#8220;<a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;7">gcc<span>&#64;</span>4<span>&#46;</span>7</a>&#8220;]</div></blockquote>
<p>Names of sections are returned as a list, e.g.:</p>
<blockquote>
<div>[<a class="reference external" href="mailto:'gcc&#37;&#52;&#48;4&#46;7">'gcc<span>&#64;</span>4<span>&#46;</span>7</a>&#8216;, <a class="reference external" href="mailto:'intel&#37;&#52;&#48;12&#46;3">'intel<span>&#64;</span>12<span>&#46;</span>3</a>&#8216;, <a class="reference external" href="mailto:'pgi&#37;&#52;&#48;4&#46;2">'pgi<span>&#64;</span>4<span>&#46;</span>2</a>&#8216;]</div></blockquote>
<p>You can get items in the sections like this:</p>
</dd></dl>

<dl class="method">
<dt id="spack.config.SpackConfigParser.get_value">
<tt class="descname">get_value</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#spack.config.SpackConfigParser.get_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.config.SpackConfigParser.has_named_section">
<tt class="descname">has_named_section</tt><big>(</big><em>section</em>, <em>name</em><big>)</big><a class="headerlink" href="#spack.config.SpackConfigParser.has_named_section" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.config.SpackConfigParser.has_value">
<tt class="descname">has_value</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#spack.config.SpackConfigParser.has_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.config.SpackConfigParser.remove_named_section">
<tt class="descname">remove_named_section</tt><big>(</big><em>section</em>, <em>name</em><big>)</big><a class="headerlink" href="#spack.config.SpackConfigParser.remove_named_section" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.config.SpackConfigParser.set_value">
<tt class="descname">set_value</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#spack.config.SpackConfigParser.set_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.config.SpackConfigParser.write">
<tt class="descname">write</tt><big>(</big><em>path_or_fp=None</em><big>)</big><a class="headerlink" href="#spack.config.SpackConfigParser.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write this configuration out to a file.</p>
<p>If called with no arguments, this will write the
configuration out to the file from which it was read.  If
this config was read from multiple files, e.g. site
configuration and then user configuration, write will
simply raise an error.</p>
<p>If called with a path or file object, this will write the
configuration out to the supplied path or file object.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.config.get_config">
<tt class="descclassname">spack.config.</tt><tt class="descname">get_config</tt><big>(</big><em>scope=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.config.get_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a Spack configuration object, which can be used to set options.</p>
<p>With no arguments, this returns a SpackConfigParser with config
options loaded from all config files.  This is how client code
should read Spack configuration options.</p>
<p>Optionally, a scope parameter can be provided.  Valid scopes
are <tt class="docutils literal"><span class="pre">site</span></tt> and <tt class="docutils literal"><span class="pre">user</span></tt>.  If a scope is provided, only the
options from that scope&#8217;s configuration file are loaded.  The
caller can set or unset options, then call <tt class="docutils literal"><span class="pre">write()</span></tt> on the
config object to write it back out to the original config file.</p>
<p>By default, this will cache configurations and return the last
read version of the config file.  If the config file is
modified and you need to refresh, call get_config with the
refresh=True keyword argument.  This will force all files to be
re-read.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.config.SpackConfigurationError">
<em class="property">exception </em><tt class="descclassname">spack.config.</tt><tt class="descname">SpackConfigurationError</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#spack.config.SpackConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
</dd></dl>

<dl class="exception">
<dt id="spack.config.InvalidConfigurationScopeError">
<em class="property">exception </em><tt class="descclassname">spack.config.</tt><tt class="descname">InvalidConfigurationScopeError</tt><big>(</big><em>scope</em><big>)</big><a class="headerlink" href="#spack.config.InvalidConfigurationScopeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.config.SpackConfigurationError" title="spack.config.SpackConfigurationError"><tt class="xref py py-class docutils literal"><span class="pre">spack.config.SpackConfigurationError</span></tt></a></p>
</dd></dl>

<dl class="exception">
<dt id="spack.config.InvalidSectionNameError">
<em class="property">exception </em><tt class="descclassname">spack.config.</tt><tt class="descname">InvalidSectionNameError</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#spack.config.InvalidSectionNameError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.config.SpackConfigurationError" title="spack.config.SpackConfigurationError"><tt class="xref py py-class docutils literal"><span class="pre">spack.config.SpackConfigurationError</span></tt></a></p>
<p>Raised when the name for a section is invalid.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.config.ReadOnlySpackConfigError">
<em class="property">exception </em><tt class="descclassname">spack.config.</tt><tt class="descname">ReadOnlySpackConfigError</tt><a class="headerlink" href="#spack.config.ReadOnlySpackConfigError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.config.SpackConfigurationError" title="spack.config.SpackConfigurationError"><tt class="xref py py-class docutils literal"><span class="pre">spack.config.SpackConfigurationError</span></tt></a></p>
<p>Raised when user attempts to write to a config read from multiple files.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.config.ConfigParserError">
<em class="property">exception </em><tt class="descclassname">spack.config.</tt><tt class="descname">ConfigParserError</tt><big>(</big><em>error</em><big>)</big><a class="headerlink" href="#spack.config.ConfigParserError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.config.SpackConfigurationError" title="spack.config.SpackConfigurationError"><tt class="xref py py-class docutils literal"><span class="pre">spack.config.SpackConfigurationError</span></tt></a></p>
<p>Wrapper for the Python ConfigParser&#8217;s errors</p>
</dd></dl>

<dl class="exception">
<dt id="spack.config.NoOptionError">
<em class="property">exception </em><tt class="descclassname">spack.config.</tt><tt class="descname">NoOptionError</tt><big>(</big><em>error</em><big>)</big><a class="headerlink" href="#spack.config.NoOptionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.config.ConfigParserError" title="spack.config.ConfigParserError"><tt class="xref py py-class docutils literal"><span class="pre">spack.config.ConfigParserError</span></tt></a></p>
<p>Wrapper for ConfigParser NoOptionError</p>
</dd></dl>

<dl class="exception">
<dt id="spack.config.NoSectionError">
<em class="property">exception </em><tt class="descclassname">spack.config.</tt><tt class="descname">NoSectionError</tt><big>(</big><em>error</em><big>)</big><a class="headerlink" href="#spack.config.NoSectionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.config.ConfigParserError" title="spack.config.ConfigParserError"><tt class="xref py py-class docutils literal"><span class="pre">spack.config.ConfigParserError</span></tt></a></p>
<p>Wrapper for ConfigParser NoOptionError</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-spack.directory_layout">
<span id="spack-directory-layout-module"></span><h2>spack.directory_layout module<a class="headerlink" href="#module-spack.directory_layout" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="spack.directory_layout.DirectoryLayout">
<em class="property">class </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">DirectoryLayout</tt><big>(</big><em>root</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A directory layout is used to associate unique paths with specs.
Different installations are going to want differnet layouts for their
install, and they can use this to customize the nesting structure of
spack installs.</p>
<dl class="method">
<dt id="spack.directory_layout.DirectoryLayout.all_specs">
<tt class="descname">all_specs</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout.all_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented by subclasses to traverse all specs for which there is
a directory within the root.</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.DirectoryLayout.make_path_for_spec">
<tt class="descname">make_path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout.make_path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the installation directory for a spec.</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.DirectoryLayout.path_for_spec">
<tt class="descname">path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout.path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an absolute path from the root to a directory for the spec.</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.DirectoryLayout.relative_path_for_spec">
<tt class="descname">relative_path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout.relative_path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Implemented by subclasses to return a relative path from the install
root to a unique location for the provided spec.</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.DirectoryLayout.remove_path_for_spec">
<tt class="descname">remove_path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout.remove_path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a prefix and any empty parent directories from the root.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.directory_layout.DirectoryLayoutError">
<em class="property">exception </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">DirectoryLayoutError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayoutError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Superclass for directory layout errors.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.directory_layout.InconsistentInstallDirectoryError">
<em class="property">exception </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">InconsistentInstallDirectoryError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.directory_layout.InconsistentInstallDirectoryError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.directory_layout.DirectoryLayoutError" title="spack.directory_layout.DirectoryLayoutError"><tt class="xref py py-class docutils literal"><span class="pre">spack.directory_layout.DirectoryLayoutError</span></tt></a></p>
<p>Raised when a package seems to be installed to the wrong place.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.directory_layout.InstallDirectoryAlreadyExistsError">
<em class="property">exception </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">InstallDirectoryAlreadyExistsError</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.directory_layout.InstallDirectoryAlreadyExistsError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.directory_layout.DirectoryLayoutError" title="spack.directory_layout.DirectoryLayoutError"><tt class="xref py py-class docutils literal"><span class="pre">spack.directory_layout.DirectoryLayoutError</span></tt></a></p>
<p>Raised when make_path_for_sec is called unnecessarily.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.directory_layout.SpecHashCollisionError">
<em class="property">exception </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">SpecHashCollisionError</tt><big>(</big><em>installed_spec</em>, <em>new_spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashCollisionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.directory_layout.DirectoryLayoutError" title="spack.directory_layout.DirectoryLayoutError"><tt class="xref py py-class docutils literal"><span class="pre">spack.directory_layout.DirectoryLayoutError</span></tt></a></p>
<p>Raised when there is a hash collision in an SpecHashDirectoryLayout.</p>
</dd></dl>

<dl class="class">
<dt id="spack.directory_layout.SpecHashDirectoryLayout">
<em class="property">class </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">SpecHashDirectoryLayout</tt><big>(</big><em>root</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.directory_layout.DirectoryLayout" title="spack.directory_layout.DirectoryLayout"><tt class="xref py py-class docutils literal"><span class="pre">spack.directory_layout.DirectoryLayout</span></tt></a></p>
<dl class="docutils">
<dt>Lays out installation directories like this::</dt>
<dd><dl class="first last docutils">
<dt>&lt;install_root&gt;/</dt>
<dd><dl class="first last docutils">
<dt>&lt;architecture&gt;/</dt>
<dd><dl class="first last docutils">
<dt>&lt;compiler&gt;/</dt>
<dd><a class="reference external" href="mailto:name&#37;&#52;&#48;version+variant">name<span>&#64;</span>version+variant</a>-&lt;dependency_hash&gt;</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>Where dependency_hash is a SHA-1 hash prefix for the full package spec.
This accounts for dependencies.</p>
<p>If there is ever a hash collision, you won&#8217;t be able to install a new
package unless you use a larger prefix.  However, the full spec is stored
in a file called .spec in each directory, so you can migrate an entire
install directory to a new hash size pretty easily.</p>
<p>TODO: make a tool to migrate install directories to different hash sizes.</p>
<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.all_specs">
<tt class="descname">all_specs</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.all_specs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.make_path_for_spec">
<tt class="descname">make_path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.make_path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.read_spec">
<tt class="descname">read_spec</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.read_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the contents of a file and parse them as a spec</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.relative_path_for_spec">
<tt class="descname">relative_path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.relative_path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.spec_file_path">
<tt class="descname">spec_file_path</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.spec_file_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets full path to spec file</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.write_spec">
<tt class="descname">write_spec</tt><big>(</big><em>spec</em>, <em>path</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.write_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a spec out to a file.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.directory_layout.traverse_dirs_at_depth">
<tt class="descclassname">spack.directory_layout.</tt><tt class="descname">traverse_dirs_at_depth</tt><big>(</big><em>root</em>, <em>depth</em>, <em>path_tuple=()</em>, <em>curdepth=0</em><big>)</big><a class="headerlink" href="#spack.directory_layout.traverse_dirs_at_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>For each directory at &lt;depth&gt; within &lt;root&gt;, return a tuple representing
the ancestors of that directory.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.error">
<span id="spack-error-module"></span><h2>spack.error module<a class="headerlink" href="#module-spack.error" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="spack.error.NoNetworkConnectionError">
<em class="property">exception </em><tt class="descclassname">spack.error.</tt><tt class="descname">NoNetworkConnectionError</tt><big>(</big><em>message</em>, <em>url</em><big>)</big><a class="headerlink" href="#spack.error.NoNetworkConnectionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when an operation needs an internet connection.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.error.SpackError">
<em class="property">exception </em><tt class="descclassname">spack.error.</tt><tt class="descname">SpackError</tt><big>(</big><em>message</em>, <em>long_message=None</em><big>)</big><a class="headerlink" href="#spack.error.SpackError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
<p>This is the superclass for all Spack errors.
Subclasses can be found in the modules they have to do with.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.error.UnsupportedPlatformError">
<em class="property">exception </em><tt class="descclassname">spack.error.</tt><tt class="descname">UnsupportedPlatformError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.error.UnsupportedPlatformError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised by packages when a platform is not supported</p>
</dd></dl>

</div>
<div class="section" id="module-spack.mirror">
<span id="spack-mirror-module"></span><h2>spack.mirror module<a class="headerlink" href="#module-spack.mirror" title="Permalink to this headline">¶</a></h2>
<p>This file contains code for creating spack mirror directories.  A
mirror is an organized hierarchy containing specially named archive
files.  This enabled spack to know where to find files in a mirror if
the main server for a particualr package is down.  Or, if the computer
where spack is run is not connected to the internet, it allows spack
to download packages directly from a mirror (e.g., on an intranet).</p>
<dl class="function">
<dt id="spack.mirror.create">
<tt class="descclassname">spack.mirror.</tt><tt class="descname">create</tt><big>(</big><em>path</em>, <em>specs=None</em><big>)</big><a class="headerlink" href="#spack.mirror.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a directory to be used as a spack mirror, and fill it with
package archives.  This iterates over all packages matching the
supplied specs.</p>
</dd></dl>

<dl class="function">
<dt id="spack.mirror.get_matching_concrete_specs">
<tt class="descclassname">spack.mirror.</tt><tt class="descname">get_matching_concrete_specs</tt><big>(</big><em>specs</em><big>)</big><a class="headerlink" href="#spack.mirror.get_matching_concrete_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a concrete spec for EACH known version matching any spec in the list.</p>
</dd></dl>

<dl class="function">
<dt id="spack.mirror.mirror_path">
<tt class="descclassname">spack.mirror.</tt><tt class="descname">mirror_path</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.mirror.mirror_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the path that this spec will live at within a mirror.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.modules">
<span id="spack-modules-module"></span><h2>spack.modules module<a class="headerlink" href="#module-spack.modules" title="Permalink to this headline">¶</a></h2>
<p>This module contains code for creating environment modules, which
can include dotkits, tcl modules, lmod, and others.</p>
<p>The various types of modules are installed by post-install hooks and
removed after an uninstall by post-uninstall hooks.  This class
consolidates the logic for creating an abstract description of the
information that module systems need.  Currently that includes a
number directories to be appended to paths in the user&#8217;s environment:</p>
<blockquote>
<div><ul class="simple">
<li>/bin directories to be appended to PATH</li>
<li>/lib* directories for LD_LIBRARY_PATH</li>
<li>/man* and /share/man* directories for LD_LIBRARY_PATH</li>
<li>the package prefix for CMAKE_PREFIX_PATH</li>
</ul>
</div></blockquote>
<p>This module also includes logic for coming up with unique names for
the module files so that they can be found by the various
shell-support files in $SPACK/share/spack/setup-env.*.</p>
<p>Each hook in hooks/ implements the logic for writing its specific type
of module file.</p>
<dl class="class">
<dt id="spack.modules.EnvModule">
<em class="property">class </em><tt class="descclassname">spack.modules.</tt><tt class="descname">EnvModule</tt><big>(</big><em>spec=None</em><big>)</big><a class="headerlink" href="#spack.modules.EnvModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="attribute">
<dt id="spack.modules.EnvModule.file_name">
<tt class="descname">file_name</tt><a class="headerlink" href="#spack.modules.EnvModule.file_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Subclasses should implement this to return the name of the file
where this module lives.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.modules.EnvModule.name">
<tt class="descname">name</tt><em class="property"> = 'env_module'</em><a class="headerlink" href="#spack.modules.EnvModule.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.modules.EnvModule.paths">
<tt class="descname">paths</tt><a class="headerlink" href="#spack.modules.EnvModule.paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.modules.EnvModule.remove">
<tt class="descname">remove</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.modules.EnvModule.remove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.modules.EnvModule.use_name">
<tt class="descname">use_name</tt><a class="headerlink" href="#spack.modules.EnvModule.use_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Subclasses should implement this to return the name the
module command uses to refer to the package.</p>
</dd></dl>

<dl class="method">
<dt id="spack.modules.EnvModule.write">
<tt class="descname">write</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.modules.EnvModule.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out a module file for this object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.modules.Dotkit">
<em class="property">class </em><tt class="descclassname">spack.modules.</tt><tt class="descname">Dotkit</tt><big>(</big><em>spec=None</em><big>)</big><a class="headerlink" href="#spack.modules.Dotkit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.modules.EnvModule" title="spack.modules.EnvModule"><tt class="xref py py-class docutils literal"><span class="pre">spack.modules.EnvModule</span></tt></a></p>
<dl class="attribute">
<dt id="spack.modules.Dotkit.file_name">
<tt class="descname">file_name</tt><a class="headerlink" href="#spack.modules.Dotkit.file_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.modules.Dotkit.name">
<tt class="descname">name</tt><em class="property"> = 'dotkit'</em><a class="headerlink" href="#spack.modules.Dotkit.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.modules.Dotkit.path">
<tt class="descname">path</tt><em class="property"> = '/Users/gamblin2/src/spack/share/spack/dotkit'</em><a class="headerlink" href="#spack.modules.Dotkit.path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.modules.Dotkit.use_name">
<tt class="descname">use_name</tt><a class="headerlink" href="#spack.modules.Dotkit.use_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.modules.TclModule">
<em class="property">class </em><tt class="descclassname">spack.modules.</tt><tt class="descname">TclModule</tt><big>(</big><em>spec=None</em><big>)</big><a class="headerlink" href="#spack.modules.TclModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.modules.EnvModule" title="spack.modules.EnvModule"><tt class="xref py py-class docutils literal"><span class="pre">spack.modules.EnvModule</span></tt></a></p>
<dl class="attribute">
<dt id="spack.modules.TclModule.file_name">
<tt class="descname">file_name</tt><a class="headerlink" href="#spack.modules.TclModule.file_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.modules.TclModule.name">
<tt class="descname">name</tt><em class="property"> = 'tcl'</em><a class="headerlink" href="#spack.modules.TclModule.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.modules.TclModule.path">
<tt class="descname">path</tt><em class="property"> = '/Users/gamblin2/src/spack/share/spack/modules'</em><a class="headerlink" href="#spack.modules.TclModule.path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.modules.TclModule.use_name">
<tt class="descname">use_name</tt><a class="headerlink" href="#spack.modules.TclModule.use_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-spack.multimethod">
<span id="spack-multimethod-module"></span><h2>spack.multimethod module<a class="headerlink" href="#module-spack.multimethod" title="Permalink to this headline">¶</a></h2>
<p>This module contains utilities for using multi-methods in
spack. You can think of multi-methods like overloaded methods &#8211;
they&#8217;re methods with the same name, and we need to select a version
of the method based on some criteria.  e.g., for overloaded
methods, you would select a version of the method to call based on
the types of its arguments.</p>
<p>In spack, multi-methods are used to ease the life of package
authors.  They allow methods like install() (or other methods
called by install()) to declare multiple versions to be called when
the package is instantiated with different specs.  e.g., if the
package is built with OpenMPI on x86_64,, you might want to call a
different install method than if it was built for mpich2 on
BlueGene/Q.  Likewise, you might want to do a different type of
install for different versions of the package.</p>
<p>Multi-methods provide a simple decorator-based syntax for this that
avoids overly complicated rat nests of if statements.  Obviously,
depending on the scenario, regular old conditionals might be clearer,
so package authors should use their judgement.</p>
<dl class="exception">
<dt id="spack.multimethod.MultiMethodError">
<em class="property">exception </em><tt class="descclassname">spack.multimethod.</tt><tt class="descname">MultiMethodError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.multimethod.MultiMethodError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Superclass for multimethod dispatch errors</p>
</dd></dl>

<dl class="exception">
<dt id="spack.multimethod.NoSuchMethodError">
<em class="property">exception </em><tt class="descclassname">spack.multimethod.</tt><tt class="descname">NoSuchMethodError</tt><big>(</big><em>cls</em>, <em>method_name</em>, <em>spec</em>, <em>possible_specs</em><big>)</big><a class="headerlink" href="#spack.multimethod.NoSuchMethodError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when we can&#8217;t find a version of a multi-method.</p>
</dd></dl>

<dl class="class">
<dt id="spack.multimethod.SpecMultiMethod">
<em class="property">class </em><tt class="descclassname">spack.multimethod.</tt><tt class="descname">SpecMultiMethod</tt><big>(</big><em>default=None</em><big>)</big><a class="headerlink" href="#spack.multimethod.SpecMultiMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This implements a multi-method for Spack specs.  Packages are
instantiated with a particular spec, and you may want to
execute different versions of methods based on what the spec
looks like.  For example, you might want to call a different
version of install() for one platform than you call on another.</p>
<p>The SpecMultiMethod class implements a callable object that
handles method dispatch.  When it is called, it looks through
registered methods and their associated specs, and it tries
to find one that matches the package&#8217;s spec.  If it finds one
(and only one), it will call that method.</p>
<p>The package author is responsible for ensuring that only one
condition on multi-methods ever evaluates to true.  If
multiple methods evaluate to true, this will raise an
exception.</p>
<p>This is intended for use with decorators (see below).  The
decorator (see docs below) creates SpecMultiMethods and
registers method versions with them.</p>
<dl class="docutils">
<dt>To register a method, you can do something like this:</dt>
<dd>mm = SpecMultiMethod()
mm.register(&#8220;^chaos_5_x86_64_ib&#8221;, some_method)</dd>
</dl>
<p>The object registered needs to be a Spec or some string that
will parse to be a valid spec.</p>
<p>When the mm is actually called, it selects a version of the
method to call based on the sys_type of the object it is
called on.</p>
<p>See the docs for decorators below for more details.</p>
<dl class="method">
<dt id="spack.multimethod.SpecMultiMethod.register">
<tt class="descname">register</tt><big>(</big><em>spec</em>, <em>method</em><big>)</big><a class="headerlink" href="#spack.multimethod.SpecMultiMethod.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a version of a method for a particular sys_type.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.multimethod.when">
<em class="property">class </em><tt class="descclassname">spack.multimethod.</tt><tt class="descname">when</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.multimethod.when" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

</div>
<div class="section" id="module-spack.package">
<span id="spack-package-module"></span><h2>spack.package module<a class="headerlink" href="#module-spack.package" title="Permalink to this headline">¶</a></h2>
<p>This is where most of the action happens in Spack.
See the Package docs for detailed instructions on how the class works
and on how to write your own packages.</p>
<p>The spack package structure is based strongly on Homebrew
(<a class="reference external" href="http://wiki.github.com/mxcl/homebrew/">http://wiki.github.com/mxcl/homebrew/</a>), mainly because
Homebrew makes it very easy to create packages.  For a complete
rundown on spack and how it differs from homebrew, look at the
README.</p>
<dl class="exception">
<dt id="spack.package.FetchError">
<em class="property">exception </em><tt class="descclassname">spack.package.</tt><tt class="descname">FetchError</tt><big>(</big><em>message</em>, <em>long_msg=None</em><big>)</big><a class="headerlink" href="#spack.package.FetchError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when something goes wrong during fetch.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.package.InstallError">
<em class="property">exception </em><tt class="descclassname">spack.package.</tt><tt class="descname">InstallError</tt><big>(</big><em>message</em>, <em>long_msg=None</em><big>)</big><a class="headerlink" href="#spack.package.InstallError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when something goes wrong during install or uninstall.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.package.InvalidPackageDependencyError">
<em class="property">exception </em><tt class="descclassname">spack.package.</tt><tt class="descname">InvalidPackageDependencyError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.package.InvalidPackageDependencyError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.package.PackageError" title="spack.package.PackageError"><tt class="xref py py-class docutils literal"><span class="pre">spack.package.PackageError</span></tt></a></p>
<p>Raised when package specification is inconsistent with requirements of
its dependencies.</p>
</dd></dl>

<dl class="class">
<dt id="spack.package.Package">
<em class="property">class </em><tt class="descclassname">spack.package.</tt><tt class="descname">Package</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.package.Package" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is the superclass for all spack packages.</p>
<p><strong>*The Package class*</strong></p>
<p>Package is where the bulk of the work of installing packages is done.</p>
<p>A package defines how to fetch, verfiy (via, e.g., md5), build, and
install a piece of software.  A Package also defines what other
packages it depends on, so that dependencies can be installed along
with the package itself.  Packages are written in pure python.</p>
<p>Packages are all submodules of spack.packages.  If spack is installed
in $prefix, all of its python files are in $prefix/lib/spack.  Most
of them are in the spack module, so all the packages live in
$prefix/lib/spack/spack/packages.</p>
<p>All you have to do to create a package is make a new subclass of Package
in this directory.  Spack automatically scans the python files there
and figures out which one to import when you invoke it.</p>
<p><strong>An example package</strong></p>
<p>Let&#8217;s look at the cmake package to start with.  This package lives in
$prefix/lib/spack/spack/packages/cmake.py:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">spack</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">class</span> <span class="nc">Cmake</span><span class="p">(</span><span class="n">Package</span><span class="p">):</span>
    <span class="n">homepage</span>  <span class="o">=</span> <span class="s">&#39;https://www.cmake.org&#39;</span>
    <span class="n">url</span>       <span class="o">=</span> <span class="s">&#39;http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz&#39;</span>
    <span class="n">md5</span>       <span class="o">=</span> <span class="s">&#39;097278785da7182ec0aea8769d06860c&#39;</span>

    <span class="k">def</span> <span class="nf">install</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="n">configure</span><span class="p">(</span><span class="s">&#39;--prefix=</span><span class="si">%s</span><span class="s">&#39;</span>   <span class="o">%</span> <span class="n">prefix</span><span class="p">,</span>
                  <span class="s">&#39;--parallel=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">make_jobs</span><span class="p">)</span>
        <span class="n">make</span><span class="p">()</span>
        <span class="n">make</span><span class="p">(</span><span class="s">&#39;install&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Naming conventions</strong></p>
<p>There are two names you should care about:</p>
<ol class="arabic">
<li><p class="first">The module name, <tt class="docutils literal"><span class="pre">cmake</span></tt>.</p>
<ul class="simple">
<li>User will refers to this name, e.g. &#8216;spack install cmake&#8217;.</li>
<li>Corresponds to the name of the file, &#8216;cmake.py&#8217;, and it can
include <tt class="docutils literal"><span class="pre">_</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, and numbers (it can even start with a
number).</li>
</ul>
</li>
<li><p class="first">The class name, &#8220;Cmake&#8221;.  This is formed by converting <cite>-</cite> or
<tt class="docutils literal"><span class="pre">_</span></tt> in the module name to camel case.  If the name starts with
a number, we prefix the class name with <tt class="docutils literal"><span class="pre">Num_</span></tt>. Examples:</p>
<blockquote>
<div><blockquote>
<div><dl class="docutils">
<dt>Module Name       Class Name</dt>
<dd><p class="first last">foo_bar           FooBar
docbook-xml       DocbookXml
FooBar            Foobar
3proxy            Num_3proxy</p>
</dd>
</dl>
</div></blockquote>
<p>The class name is what spack looks for when it loads a package module.</p>
</div></blockquote>
</li>
</ol>
<p><strong>Required Attributes</strong></p>
<p>Aside from proper naming, here is the bare minimum set of things you
need when you make a package:</p>
<dl class="docutils">
<dt>homepage</dt>
<dd>informational URL, so that users know what they&#8217;re
installing.</dd>
<dt>url</dt>
<dd>URL of the source archive that spack will fetch.</dd>
<dt>install()</dt>
<dd>This function tells spack how to build and install the
software it downloaded.</dd>
</dl>
<p><strong>Optional Attributes</strong></p>
<p>You can also optionally add these attributes, if needed:</p>
<blockquote>
<div><dl class="docutils">
<dt>list_url</dt>
<dd>Webpage to scrape for available version strings. Default is the
directory containing the tarball; use this if the default isn&#8217;t
correct so that invoking &#8216;spack versions&#8217; will work for this
package.</dd>
<dt>url_version(self, version)</dt>
<dd>When spack downloads packages at particular versions, it just
converts version to string with str(version).  Override this if
your package needs special version formatting in its URL.  boost
is an example of a package that needs this.</dd>
</dl>
</div></blockquote>
<p><strong>*Creating Packages*</strong></p>
<p>As a package creator, you can probably ignore most of the preceding
information, because you can use the &#8216;spack create&#8217; command to do it
all automatically.</p>
<p>You as the package creator generally only have to worry about writing
your install function and specifying dependencies.</p>
<p><strong>spack create</strong></p>
<dl class="docutils">
<dt>Most software comes in nicely packaged tarballs, like this one:</dt>
<dd><a class="reference external" href="http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz">http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz</a></dd>
</dl>
<p>Taking a page from homebrew, spack deduces pretty much everything it
needs to know from the URL above.  If you simply type this:</p>
<blockquote>
<div>spack create <a class="reference external" href="http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz">http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz</a></div></blockquote>
<p>Spack will download the tarball, generate an md5 hash, figure out the
version and the name of the package from the URL, and create a new
package file for you with all the names and attributes set correctly.</p>
<p>Once this skeleton code is generated, spack pops up the new package in
your $EDITOR so that you can modify the parts that need changes.</p>
<p><strong>Dependencies</strong></p>
<p>If your package requires another in order to build, you can specify that
like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Stackwalker</span><span class="p">(</span><span class="n">Package</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">depends_on</span><span class="p">(</span><span class="s">&quot;libdwarf&quot;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This tells spack that before it builds stackwalker, it needs to build
the libdwarf package as well.  Note that this is the module name, not
the class name (The class name is really only used by spack to find
your package).</p>
<p>Spack will download an install each dependency before it installs your
package.  In addtion, it will add -L, -I, and rpath arguments to your
compiler and linker for each dependency.  In most cases, this allows you
to avoid specifying any dependencies in your configure or cmake line;
you can just run configure or cmake without any additional arguments and
it will find the dependencies automatically.</p>
<p><strong>The Install Function</strong></p>
<p>The install function is designed so that someone not too terribly familiar
with Python could write a package installer.  For example, we put a number
of commands in install scope that you can use almost like shell commands.
These include make, configure, cmake, rm, rmtree, mkdir, mkdirp, and others.</p>
<p>You can see above in the cmake script that these commands are used to run
configure and make almost like they&#8217;re used on the command line.  The
only difference is that they are python function calls and not shell
commands.</p>
<p>It may be puzzling to you where the commands and functions in install live.
They are NOT instance variables on the class; this would require us to
type &#8216;self.&#8217; all the time and it makes the install code unnecessarily long.
Rather, spack puts these commands and variables in <em>module</em> scope for your
Package subclass.  Since each package has its own module, this doesn&#8217;t
pollute other namespaces, and it allows you to more easily implement an
install function.</p>
<p>For a full list of commands and variables available in module scope, see the
add_commands_to_module() function in this class. This is where most of
them are created and set on the module.</p>
<p><strong>Parallel Builds</strong></p>
<p>By default, Spack will run make in parallel when you run make() in your
install function.  Spack figures out how many cores are available on
your system and runs make with -j&lt;cores&gt;.  If you do not want this behavior,
you can explicitly mark a package not to use parallel make:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SomePackage</span><span class="p">(</span><span class="n">Package</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">parallel</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This changes thd default behavior so that make is sequential.  If you still
want to build some parts in parallel, you can do this in your install function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">make</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Likewise, if you do not supply parallel = True in your Package, you can keep
the default parallel behavior and run make like this when you want a
sequential build:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">make</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Package Lifecycle</strong></p>
<p>This section is really only for developers of new spack commands.</p>
<p>A package&#8217;s lifecycle over a run of Spack looks something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Package</span><span class="p">()</span>             <span class="c"># Done for you by spack</span>

<span class="n">p</span><span class="o">.</span><span class="n">do_fetch</span><span class="p">()</span>              <span class="c"># downloads tarball from a URL</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_stage</span><span class="p">()</span>              <span class="c"># expands tarball in a temp directory</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_patch</span><span class="p">()</span>              <span class="c"># applies patches to expanded source</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_install</span><span class="p">()</span>            <span class="c"># calls package&#39;s install() function</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_uninstall</span><span class="p">()</span>          <span class="c"># removes install directory</span>
</pre></div>
</div>
<p>There are also some other commands that clean the build area:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span><span class="o">.</span><span class="n">do_clean</span><span class="p">()</span>              <span class="c"># runs make clean</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_clean_work</span><span class="p">()</span>         <span class="c"># removes the build directory and</span>
                          <span class="c"># re-expands the archive.</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_clean_dist</span><span class="p">()</span>         <span class="c"># removes the stage directory entirely</span>
</pre></div>
</div>
<p>The convention used here is that a do_* function is intended to be called
internally by Spack commands (in spack.cmd).  These aren&#8217;t for package
writers to override, and doing so may break the functionality of the Package
class.</p>
<p>Package creators override functions like install() (all of them do this),
clean() (some of them do this), and others to provide custom behavior.</p>
<dl class="attribute">
<dt id="spack.package.Package.available_versions">
<tt class="descname">available_versions</tt><a class="headerlink" href="#spack.package.Package.available_versions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.clean">
<tt class="descname">clean</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>By default just runs make clean.  Override if this isn&#8217;t good.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.compiler">
<tt class="descname">compiler</tt><a class="headerlink" href="#spack.package.Package.compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the spack.compiler.Compiler object used to build this package.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.conflicted">
<tt class="descname">conflicted</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.package.Package.conflicted" title="Permalink to this definition">¶</a></dt>
<dd><p>Patches to apply to newly expanded source, if any.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.default_url">
<tt class="descname">default_url</tt><a class="headerlink" href="#spack.package.Package.default_url" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.dependencies">
<tt class="descname">dependencies</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.package.Package.dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Specs of virtual packages provided by this package, keyed by name.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_clean">
<tt class="descname">do_clean</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_clean_dist">
<tt class="descname">do_clean_dist</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_clean_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the stage directory where this package was built.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_clean_work">
<tt class="descname">do_clean_work</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_clean_work" title="Permalink to this definition">¶</a></dt>
<dd><p>By default just blows away the stage directory and re-stages.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_fetch">
<tt class="descname">do_fetch</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a stage directory and downloads the taball for this package.
Working directory will be set to the stage directory.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_install">
<tt class="descname">do_install</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.package.Package.do_install" title="Permalink to this definition">¶</a></dt>
<dd><p>This class should call this version of the install method.
Package implementations should override install().</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_install_dependencies">
<tt class="descname">do_install_dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_install_dependencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_patch">
<tt class="descname">do_patch</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_patch" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls do_stage(), then applied patches to the expanded tarball if they
haven&#8217;t been applied already.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_stage">
<tt class="descname">do_stage</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_stage" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpacks the fetched tarball, then changes into the expanded tarball
directory.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_uninstall">
<tt class="descname">do_uninstall</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.package.Package.do_uninstall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.fetch_available_versions">
<tt class="descname">fetch_available_versions</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.fetch_available_versions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.install">
<tt class="descname">install</tt><big>(</big><em>spec</em>, <em>prefix</em><big>)</big><a class="headerlink" href="#spack.package.Package.install" title="Permalink to this definition">¶</a></dt>
<dd><p>Package implementations override this with their own build configuration.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.installed">
<tt class="descname">installed</tt><a class="headerlink" href="#spack.package.Package.installed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.installed_dependents">
<tt class="descname">installed_dependents</tt><a class="headerlink" href="#spack.package.Package.installed_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the specs of all installed packages that depend
on this one.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.module">
<tt class="descname">module</tt><a class="headerlink" href="#spack.package.Package.module" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this to add variables to the class&#8217;s module&#8217;s scope.
This lets us use custom syntax in the install method.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.parallel">
<tt class="descname">parallel</tt><em class="property"> = True</em><a class="headerlink" href="#spack.package.Package.parallel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.patches">
<tt class="descname">patches</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.package.Package.patches" title="Permalink to this definition">¶</a></dt>
<dd><p>By default we build in parallel.  Subclasses can override this.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.prefix">
<tt class="descname">prefix</tt><a class="headerlink" href="#spack.package.Package.prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the prefix into which this package should be installed.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.preorder_traversal">
<tt class="descname">preorder_traversal</tt><big>(</big><em>visited=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.package.Package.preorder_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>This does a preorder traversal of the package&#8217;s dependence DAG.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.provided">
<tt class="descname">provided</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.package.Package.provided" title="Permalink to this definition">¶</a></dt>
<dd><p>Specs of conflicting packages, keyed by name.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.provides">
<tt class="descname">provides</tt><big>(</big><em>vpkg_name</em><big>)</big><a class="headerlink" href="#spack.package.Package.provides" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this package provides a virtual package with the specified name.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.remove_prefix">
<tt class="descname">remove_prefix</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.remove_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the prefix for a package along with any empty parent directories.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.stage">
<tt class="descname">stage</tt><a class="headerlink" href="#spack.package.Package.stage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.url_for_version">
<tt class="descname">url_for_version</tt><big>(</big><em>version</em><big>)</big><a class="headerlink" href="#spack.package.Package.url_for_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a URL that you can download a new version of this package from.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.url_version">
<tt class="descname">url_version</tt><big>(</big><em>version</em><big>)</big><a class="headerlink" href="#spack.package.Package.url_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a version, this returns a string that should be substituted into the
package&#8217;s URL to download that version.
By default, this just returns the version string. Subclasses may need to
override this, e.g. for boost versions where you need to ensure that there
are _&#8217;s in the download URL.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.validate_dependencies">
<tt class="descname">validate_dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.validate_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that this package and its dependencies all have consistent
constraints on them.</p>
<p>NOTE that this will NOT find sanity problems through a virtual
dependency.  Virtual deps complicate the problem because we
don&#8217;t know in advance which ones conflict with others in the
dependency DAG. If there&#8217;s more than one virtual dependency,
it&#8217;s a full-on SAT problem, so hold off on this for now.
The vdeps are actually skipped in preorder_traversal, so see
that for details.</p>
<p>TODO: investigate validating virtual dependencies.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.version">
<tt class="descname">version</tt><a class="headerlink" href="#spack.package.Package.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.versions">
<tt class="descname">versions</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.package.Package.versions" title="Permalink to this definition">¶</a></dt>
<dd><p>Specs of dependency packages, keyed by name.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.virtual_dependencies">
<tt class="descname">virtual_dependencies</tt><big>(</big><em>visited=None</em><big>)</big><a class="headerlink" href="#spack.package.Package.virtual_dependencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.package.PackageError">
<em class="property">exception </em><tt class="descclassname">spack.package.</tt><tt class="descname">PackageError</tt><big>(</big><em>message</em>, <em>long_msg=None</em><big>)</big><a class="headerlink" href="#spack.package.PackageError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when something is wrong with a package definition.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.package.PackageVersionError">
<em class="property">exception </em><tt class="descclassname">spack.package.</tt><tt class="descname">PackageVersionError</tt><big>(</big><em>version</em><big>)</big><a class="headerlink" href="#spack.package.PackageVersionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.package.PackageError" title="spack.package.PackageError"><tt class="xref py py-class docutils literal"><span class="pre">spack.package.PackageError</span></tt></a></p>
<p>Raised when a version URL cannot automatically be determined.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.package.VersionFetchError">
<em class="property">exception </em><tt class="descclassname">spack.package.</tt><tt class="descname">VersionFetchError</tt><big>(</big><em>cls</em><big>)</big><a class="headerlink" href="#spack.package.VersionFetchError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.package.PackageError" title="spack.package.PackageError"><tt class="xref py py-class docutils literal"><span class="pre">spack.package.PackageError</span></tt></a></p>
<p>Raised when a version URL cannot automatically be determined.</p>
</dd></dl>

<dl class="function">
<dt id="spack.package.find_versions_of_archive">
<tt class="descclassname">spack.package.</tt><tt class="descname">find_versions_of_archive</tt><big>(</big><em>archive_url</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.package.find_versions_of_archive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.package.print_pkg">
<tt class="descclassname">spack.package.</tt><tt class="descname">print_pkg</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.package.print_pkg" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a message with a package icon.</p>
</dd></dl>

<dl class="function">
<dt id="spack.package.validate_package_url">
<tt class="descclassname">spack.package.</tt><tt class="descname">validate_package_url</tt><big>(</big><em>url_string</em><big>)</big><a class="headerlink" href="#spack.package.validate_package_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether spack can handle a particular URL or not.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.packages">
<span id="spack-packages-module"></span><h2>spack.packages module<a class="headerlink" href="#module-spack.packages" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="spack.packages.FailedConstructorError">
<em class="property">exception </em><tt class="descclassname">spack.packages.</tt><tt class="descname">FailedConstructorError</tt><big>(</big><em>name</em>, <em>reason</em><big>)</big><a class="headerlink" href="#spack.packages.FailedConstructorError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when a package&#8217;s class constructor fails.</p>
</dd></dl>

<dl class="class">
<dt id="spack.packages.PackageDB">
<em class="property">class </em><tt class="descclassname">spack.packages.</tt><tt class="descname">PackageDB</tt><big>(</big><em>root</em><big>)</big><a class="headerlink" href="#spack.packages.PackageDB" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="spack.packages.PackageDB.all_package_names">
<tt class="descname">all_package_names</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.all_package_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator function for all packages.  This looks for
<tt class="docutils literal"><span class="pre">&lt;pkg_name&gt;/package.py</span></tt> files within the root direcotry</p>
</dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.all_packages">
<tt class="descname">all_packages</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.all_packages" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.dirname_for_package_name">
<tt class="descname">dirname_for_package_name</tt><big>(</big><em>pkg_name</em><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.dirname_for_package_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the directory name for a particular package.  This is the
directory that contains its package.py file.</p>
</dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.exists">
<tt class="descname">exists</tt><big>(</big><em>pkg_name</em><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether a package with the supplied name exists .</p>
</dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.filename_for_package_name">
<tt class="descname">filename_for_package_name</tt><big>(</big><em>pkg_name</em><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.filename_for_package_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the filename for the module we should load for a particular
package.  Packages for a pacakge DB live in
<tt class="docutils literal"><span class="pre">$root/&lt;package_name&gt;/package.py</span></tt></p>
<p>This will return a proper package.py path even if the
package doesn&#8217;t exist yet, so callers will need to ensure
the package exists before importing.</p>
</dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.get">
<tt class="descname">get</tt><big>(</big><em>spec_like</em><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.get_class_for_package_name">
<tt class="descname">get_class_for_package_name</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.get_class_for_package_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an instance of the class for a particular package.</p>
<p>This method uses Python&#8217;s <tt class="docutils literal"><span class="pre">imp</span></tt> package to load python
source from a Spack package&#8217;s <tt class="docutils literal"><span class="pre">package.py</span></tt> file.  A
normal python import would only load each package once, but
because we do this dynamically, the method needs to be
memoized to ensure there is only ONE package class
instance, per package, per database.</p>
</dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.get_installed">
<tt class="descname">get_installed</tt><big>(</big><em>spec_like</em><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.get_installed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.graph_dependencies">
<tt class="descname">graph_dependencies</tt><big>(</big><em>out=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0x10d36d150&gt;</em><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.graph_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Print out a graph of all the dependencies between package.
Graph is in dot format.</p>
</dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.installed_known_package_specs">
<tt class="descname">installed_known_package_specs</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.installed_known_package_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>Read installed package names straight from the install
directory layout, but return only specs for which the
package is known to this version of spack.</p>
</dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.installed_package_specs">
<tt class="descname">installed_package_specs</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.installed_package_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>Read installed package names straight from the install directory
layout.</p>
</dd></dl>

<dl class="method">
<dt id="spack.packages.PackageDB.providers_for">
<tt class="descname">providers_for</tt><big>(</big><em>spec_like</em><big>)</big><a class="headerlink" href="#spack.packages.PackageDB.providers_for" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.packages.UnknownPackageError">
<em class="property">exception </em><tt class="descclassname">spack.packages.</tt><tt class="descname">UnknownPackageError</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#spack.packages.UnknownPackageError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when we encounter a package spack doesn&#8217;t have.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.parse">
<span id="spack-parse-module"></span><h2>spack.parse module<a class="headerlink" href="#module-spack.parse" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="spack.parse.LexError">
<em class="property">exception </em><tt class="descclassname">spack.parse.</tt><tt class="descname">LexError</tt><big>(</big><em>message</em>, <em>string</em>, <em>pos</em><big>)</big><a class="headerlink" href="#spack.parse.LexError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.parse.ParseError" title="spack.parse.ParseError"><tt class="xref py py-class docutils literal"><span class="pre">spack.parse.ParseError</span></tt></a></p>
<p>Raised when we don&#8217;t know how to lex something.</p>
</dd></dl>

<dl class="class">
<dt id="spack.parse.Lexer">
<em class="property">class </em><tt class="descclassname">spack.parse.</tt><tt class="descname">Lexer</tt><big>(</big><em>lexicon</em><big>)</big><a class="headerlink" href="#spack.parse.Lexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for Lexers that keep track of line numbers.</p>
<dl class="method">
<dt id="spack.parse.Lexer.lex">
<tt class="descname">lex</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#spack.parse.Lexer.lex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.parse.Lexer.token">
<tt class="descname">token</tt><big>(</big><em>type</em>, <em>value=''</em><big>)</big><a class="headerlink" href="#spack.parse.Lexer.token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.parse.ParseError">
<em class="property">exception </em><tt class="descclassname">spack.parse.</tt><tt class="descname">ParseError</tt><big>(</big><em>message</em>, <em>string</em>, <em>pos</em><big>)</big><a class="headerlink" href="#spack.parse.ParseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when we don&#8217;t hit an error while parsing.</p>
</dd></dl>

<dl class="class">
<dt id="spack.parse.Parser">
<em class="property">class </em><tt class="descclassname">spack.parse.</tt><tt class="descname">Parser</tt><big>(</big><em>lexer</em><big>)</big><a class="headerlink" href="#spack.parse.Parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for simple recursive descent parsers.</p>
<dl class="method">
<dt id="spack.parse.Parser.accept">
<tt class="descname">accept</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Puts the next symbol in self.token if we like it.  Then calls gettok()</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.expect">
<tt class="descname">expect</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.expect" title="Permalink to this definition">¶</a></dt>
<dd><p>Like accept(), but fails if we don&#8217;t like the next token.</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.gettok">
<tt class="descname">gettok</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.parse.Parser.gettok" title="Permalink to this definition">¶</a></dt>
<dd><p>Puts the next token in the input stream into self.next.</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.last_token_error">
<tt class="descname">last_token_error</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.last_token_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an error about the previous token in the stream.</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.next_token_error">
<tt class="descname">next_token_error</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.next_token_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an error about the next token in the stream.</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.parse">
<tt class="descname">parse</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.push_tokens">
<tt class="descname">push_tokens</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.push_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds all tokens in some iterable to the token stream.</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.setup">
<tt class="descname">setup</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.setup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.unexpected_token">
<tt class="descname">unexpected_token</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.parse.Parser.unexpected_token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.parse.Token">
<em class="property">class </em><tt class="descclassname">spack.parse.</tt><tt class="descname">Token</tt><big>(</big><em>type</em>, <em>value=''</em>, <em>start=0</em>, <em>end=0</em><big>)</big><a class="headerlink" href="#spack.parse.Token" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents tokens; generated from input by lexer and fed to parse().</p>
<dl class="method">
<dt id="spack.parse.Token.is_a">
<tt class="descname">is_a</tt><big>(</big><em>type</em><big>)</big><a class="headerlink" href="#spack.parse.Token.is_a" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-spack.patch">
<span id="spack-patch-module"></span><h2>spack.patch module<a class="headerlink" href="#module-spack.patch" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="spack.patch.NoSuchPatchFileError">
<em class="property">exception </em><tt class="descclassname">spack.patch.</tt><tt class="descname">NoSuchPatchFileError</tt><big>(</big><em>package</em>, <em>path</em><big>)</big><a class="headerlink" href="#spack.patch.NoSuchPatchFileError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when user specifies a patch file that doesn&#8217;t exist.</p>
</dd></dl>

<dl class="class">
<dt id="spack.patch.Patch">
<em class="property">class </em><tt class="descclassname">spack.patch.</tt><tt class="descname">Patch</tt><big>(</big><em>pkg_name</em>, <em>path_or_url</em>, <em>level</em><big>)</big><a class="headerlink" href="#spack.patch.Patch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class describes a patch to be applied to some expanded
source code.</p>
<dl class="method">
<dt id="spack.patch.Patch.apply">
<tt class="descname">apply</tt><big>(</big><em>stage</em><big>)</big><a class="headerlink" href="#spack.patch.Patch.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch this patch, if necessary, and apply it to the source
code in the supplied stage.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-spack.relations">
<span id="spack-relations-module"></span><h2>spack.relations module<a class="headerlink" href="#module-spack.relations" title="Permalink to this headline">¶</a></h2>
<p>This package contains relationships that can be defined among packages.
Relations are functions that can be called inside a package definition,
for example:</p>
<blockquote>
<div><dl class="docutils">
<dt>class OpenMPI(Package):</dt>
<dd>depends_on(&#8220;hwloc&#8221;)
provides(&#8220;mpi&#8221;)
...</dd>
</dl>
</div></blockquote>
<p>The available relations are:</p>
<dl class="docutils">
<dt>depends_on</dt>
<dd>Above, the OpenMPI package declares that it &#8220;depends on&#8221; hwloc.  This means
that the hwloc package needs to be installed before OpenMPI can be
installed.  When a user runs &#8216;spack install openmpi&#8217;, spack will fetch
hwloc and install it first.</dd>
<dt>provides</dt>
<dd><p class="first">This is useful when more than one package can satisfy a dependence.  Above,
OpenMPI declares that it &#8220;provides&#8221; mpi.  Other implementations of the MPI
interface, like mvapich and mpich, also provide mpi, e.g.:</p>
<blockquote>
<div><dl class="docutils">
<dt>class Mvapich(Package):</dt>
<dd>provides(&#8220;mpi&#8221;)
...</dd>
<dt>class Mpich(Package):</dt>
<dd>provides(&#8220;mpi&#8221;)
...</dd>
</dl>
</div></blockquote>
<p>Instead of depending on openmpi, mvapich, or mpich, another package can
declare that it depends on &#8220;mpi&#8221;:</p>
<blockquote>
<div><dl class="docutils">
<dt>class Mpileaks(Package):</dt>
<dd>depends_on(&#8220;mpi&#8221;)
...</dd>
</dl>
</div></blockquote>
<p>Now the user can pick which MPI they would like to build with when they
install mpileaks.  For example, the user could install 3 instances of
mpileaks, one for each MPI version, by issuing these three commands:</p>
<blockquote class="last">
<div>spack install mpileaks ^openmpi
spack install mpileaks ^mvapich
spack install mpileaks ^mpich</div></blockquote>
</dd>
</dl>
<dl class="function">
<dt id="spack.relations.depends_on">
<tt class="descclassname">spack.relations.</tt><tt class="descname">depends_on</tt><big>(</big><em>*specs</em><big>)</big><a class="headerlink" href="#spack.relations.depends_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a dependencies local variable in the locals of
the calling class, based on args.</p>
</dd></dl>

<dl class="function">
<dt id="spack.relations.provides">
<tt class="descclassname">spack.relations.</tt><tt class="descname">provides</tt><big>(</big><em>*specs</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.relations.provides" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows packages to provide a virtual dependency.  If a package provides
&#8216;mpi&#8217;, other packages can declare that they depend on &#8220;mpi&#8221;, and spack
can use the providing package to satisfy the dependency.</p>
</dd></dl>

<dl class="function">
<dt id="spack.relations.patch">
<tt class="descclassname">spack.relations.</tt><tt class="descname">patch</tt><big>(</big><em>url_or_filename</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.relations.patch" title="Permalink to this definition">¶</a></dt>
<dd><p>Packages can declare patches to apply to source.  You can
optionally provide a when spec to indicate that a particular
patch should only be applied when the package&#8217;s spec meets
certain conditions (e.g. a particular version).</p>
</dd></dl>

<dl class="function">
<dt id="spack.relations.version">
<tt class="descclassname">spack.relations.</tt><tt class="descname">version</tt><big>(</big><em>ver</em>, <em>checksum</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.relations.version" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a version and associated metadata to the package.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.spec">
<span id="spack-spec-module"></span><h2>spack.spec module<a class="headerlink" href="#module-spack.spec" title="Permalink to this headline">¶</a></h2>
<p>Spack allows very fine-grained control over how packages are installed and
over how they are built and configured.  To make this easy, it has its own
syntax for declaring a dependence.  We call a descriptor of a particular
package configuration a &#8220;spec&#8221;.</p>
<p>The syntax looks like this:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span>spack install mpileaks ^openmpi @1.2:1.4 +debug %intel @12.1 <span class="o">=</span>bgqos_0
                0        1        2        3      4      5     6
</pre></div>
</div>
<p>The first part of this is the command, &#8216;spack install&#8217;.  The rest of the
line is a spec for a particular installation of the mpileaks package.</p>
<ol class="arabic" start="0">
<li><p class="first">The package to install</p>
</li>
<li><p class="first">A dependency of the package, prefixed by ^</p>
</li>
<li><p class="first">A version descriptor for the package.  This can either be a specific
version, like &#8220;1.2&#8221;, or it can be a range of versions, e.g. &#8220;1.2:1.4&#8221;.
If multiple specific versions or multiple ranges are acceptable, they
can be separated by commas, e.g. if a package will only build with
versions 1.0, 1.2-1.4, and 1.6-1.8 of mavpich, you could say:</p>
<blockquote>
<div><p>depends_on(&#8220;<a class="reference external" href="mailto:mvapich&#37;&#52;&#48;1&#46;0">mvapich<span>&#64;</span>1<span>&#46;</span>0</a>,1.2:1.4,1.6:1.8&#8221;)</p>
</div></blockquote>
</li>
<li><p class="first">A compile-time variant of the package.  If you need openmpi to be
built in debug mode for your package to work, you can require it by
adding +debug to the openmpi spec when you depend on it.  If you do
NOT want the debug option to be enabled, then replace this with -debug.</p>
</li>
<li><p class="first">The name of the compiler to build with.</p>
</li>
<li><p class="first">The versions of the compiler to build with.  Note that the identifier
for a compiler version is the same &#8216;&#64;&#8217; that is used for a package version.
A version list denoted by &#8216;&#64;&#8217; is associated with the compiler only if
if it comes immediately after the compiler name.  Otherwise it will be
associated with the current package spec.</p>
</li>
<li><p class="first">The architecture to build with.  This is needed on machines where
cross-compilation is required</p>
</li>
</ol>
<p>Here is the EBNF grammar for a spec:</p>
<div class="highlight-python"><div class="highlight"><pre>spec-list    = { spec [ dep-list ] }
dep_list     = { ^ spec }
spec         = id [ options ]
options      = { @version-list | +variant | -variant | ~variant |
                 %compiler | =architecture }
variant      = id
architecture = id
compiler     = id [ version-list ]
version-list = version [ { , version } ]
version      = id | id: | :id | id:id
id           = [A-Za-z0-9_][A-Za-z0-9_.-]*
</pre></div>
</div>
<p>There is one context-sensitive part: ids in versions may contain &#8216;.&#8217;, while
other ids may not.</p>
<p>There is one ambiguity: since &#8216;-&#8216; is allowed in an id, you need to put
whitespace space before -variant for it to be tokenized properly.  You can
either use whitespace, or you can just use ~variant since it means the same
thing.  Spack uses ~variant in directory names and in the canonical form of
specs to avoid ambiguity.  Both are provided because ~ can cause shell
expansion when it is the first character in an id typed on the command line.</p>
<dl class="class">
<dt id="spack.spec.CompilerSpec">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">CompilerSpec</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#spack.spec.CompilerSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The CompilerSpec field represents the compiler or range of compiler
versions that a package should be built with.  CompilerSpecs have a
name and a version list.</p>
<dl class="attribute">
<dt id="spack.spec.CompilerSpec.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.spec.CompilerSpec.concrete" title="Permalink to this definition">¶</a></dt>
<dd><p>A CompilerSpec is concrete if its versions are concrete and there
is an available compiler with the right version.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.CompilerSpec.constrain">
<tt class="descname">constrain</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.CompilerSpec.constrain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.CompilerSpec.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.CompilerSpec.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.CompilerSpec.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.CompilerSpec.satisfies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.spec.CompilerSpec.version">
<tt class="descname">version</tt><a class="headerlink" href="#spack.spec.CompilerSpec.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.spec.DependencyMap">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">DependencyMap</tt><a class="headerlink" href="#spack.spec.DependencyMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">llnl.util.lang.HashableMap</span></tt></p>
<p>Each spec has a DependencyMap containing specs for its dependencies.
The DependencyMap is keyed by name.</p>
<dl class="attribute">
<dt id="spack.spec.DependencyMap.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.spec.DependencyMap.concrete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.spec.DuplicateArchitectureError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">DuplicateArchitectureError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.DuplicateArchitectureError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when the same architecture occurs in a spec twice.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.DuplicateCompilerSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">DuplicateCompilerSpecError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.DuplicateCompilerSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when the same compiler occurs in a spec twice.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.DuplicateDependencyError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">DuplicateDependencyError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.DuplicateDependencyError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when the same dependency occurs in a spec twice.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.DuplicateVariantError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">DuplicateVariantError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.DuplicateVariantError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when the same variant occurs in a spec twice.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.InconsistentSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">InconsistentSpecError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.InconsistentSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when two nodes in the same spec DAG have inconsistent
constraints.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.InvalidDependencyException">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">InvalidDependencyException</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.InvalidDependencyException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when a dependency in a spec is not actually a dependency
of the package.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.MultipleProviderError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">MultipleProviderError</tt><big>(</big><em>vpkg</em>, <em>providers</em><big>)</big><a class="headerlink" href="#spack.spec.MultipleProviderError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when there is no package that provides a particular
virtual dependency.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.NoProviderError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">NoProviderError</tt><big>(</big><em>vpkg</em><big>)</big><a class="headerlink" href="#spack.spec.NoProviderError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when there is no package that provides a particular
virtual dependency.</p>
</dd></dl>

<dl class="class">
<dt id="spack.spec.Spec">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">Spec</tt><big>(</big><em>spec_like</em>, <em>*dep_like</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="spack.spec.Spec.colorized">
<tt class="descname">colorized</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.colorized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.common_dependencies">
<tt class="descname">common_dependencies</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.common_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return names of dependencies that self an other have in common.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.spec.Spec.concrete" title="Permalink to this definition">¶</a></dt>
<dd><p>A spec is concrete if it can describe only ONE build of a package.
If any of the name, version, architecture, compiler, or depdenencies
are ambiguous,then it is not concrete.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.concretize">
<tt class="descname">concretize</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.concretize" title="Permalink to this definition">¶</a></dt>
<dd><p>A spec is concrete if it describes one build of a package uniquely.
This will ensure that this spec is concrete.</p>
<p>If this spec could describe more than one version, variant, or build
of a package, this will add constraints to make it concrete.</p>
<p>Some rigorous validation and checks are also performed on the spec.
Concretizing ensures that it is self-consistent and that it&#8217;s consistent
with requirements of its pacakges.  See flatten() and normalize() for
more details on this.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.concretized">
<tt class="descname">concretized</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.concretized" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a non-destructive version of concretize().  First clones,
then returns a concrete version of this package without modifying
this package.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.constrain">
<tt class="descname">constrain</tt><big>(</big><em>other</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.constrain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.copy">
<tt class="descname">copy</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this spec.
By default, returns a deep copy.  Supply dependencies=False
to get a shallow copy.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.dep_difference">
<tt class="descname">dep_difference</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.dep_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns dependencies in self that are not in other.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.dep_hash">
<tt class="descname">dep_hash</tt><big>(</big><em>length=None</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.dep_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a hash representing all dependencies of this spec
(direct and indirect).</p>
<p>If you want this hash to be consistent, you should
concretize the spec first so that it is not ambiguous.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.dep_string">
<tt class="descname">dep_string</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.dep_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.eq_dag">
<tt class="descname">eq_dag</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.eq_dag" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the full dependency DAGs of specs are equal</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.eq_node">
<tt class="descname">eq_node</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.eq_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Equality with another spec, not including dependencies.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.flat_dependencies">
<tt class="descname">flat_dependencies</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.flat_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a DependencyMap containing all of this spec&#8217;s
dependencies with their constraints merged.</p>
<p>If copy is True, returns merged copies of its dependencies
without modifying the spec it&#8217;s called on.</p>
<p>If copy is False, clears this spec&#8217;s dependencies and
returns them.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.flatten">
<tt class="descname">flatten</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Pull all dependencies up to the root (this spec).
Merge constraints for dependencies with the same name, and if they
conflict, throw an exception.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.format">
<tt class="descname">format</tt><big>(</big><em>format_string='$_$&#64;$%&#64;$+$='</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints out particular pieces of a spec, depending on what is
in the format string.  The format strings you can provide are:</p>
<div class="highlight-python"><div class="highlight"><pre>$_   Package name
$@   Version
$%   Compiler
$%@  Compiler &amp; compiler version
$+   Options
$=   Architecture
$#   Dependencies&#39; 8-char sha1 prefix
$$   $
</pre></div>
</div>
<p>Optionally you can provide a width, e.g. $20_ for a 20-wide name.
Like printf, you can provide &#8216;-&#8216; for left justification, e.g.
$-<a href="#id1"><span class="problematic" id="id2">20_</span></a> for a left-justified name.</p>
<p>Anything else is copied verbatim into the output stream.</p>
<p><em>Example:</em>  <tt class="docutils literal"><span class="pre">$_$&#64;$+</span></tt> translates to the name, version, and options
of the package, but no dependencies, arch, or compiler.</p>
<p>TODO: allow, e.g., $6# to customize short hash length
TODO: allow, e.g., $## for full hash.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.ne_dag">
<tt class="descname">ne_dag</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.ne_dag" title="Permalink to this definition">¶</a></dt>
<dd><p>True if the full dependency DAGs of specs are not equal</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.ne_node">
<tt class="descname">ne_node</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.ne_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Inequality with another spec, not including dependencies.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.normalize">
<tt class="descname">normalize</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>When specs are parsed, any dependencies specified are hanging off
the root, and ONLY the ones that were explicitly provided are there.
Normalization turns a partial flat spec into a DAG, where:</p>
<ol class="arabic simple">
<li>ALL dependencies of the root package are in the DAG.</li>
<li>Each node&#8217;s dependencies dict only contains its direct deps.</li>
<li>There is only ONE unique spec for each package in the DAG.<ul>
<li>This includes virtual packages.  If there a non-virtual
package that provides a virtual package that is in the spec,
then we replace the virtual package with the non-virtual one.</li>
</ul>
</li>
<li>The spec DAG matches package DAG.</li>
</ol>
<p>TODO: normalize should probably implement some form of cycle detection,
to ensure that the spec is actually a DAG.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.normalized">
<tt class="descname">normalized</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.normalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a normalized copy of this spec without modifying this spec.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.package">
<tt class="descname">package</tt><a class="headerlink" href="#spack.spec.Spec.package" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.prefix">
<tt class="descname">prefix</tt><a class="headerlink" href="#spack.spec.Spec.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.root">
<tt class="descname">root</tt><a class="headerlink" href="#spack.spec.Spec.root" title="Permalink to this definition">¶</a></dt>
<dd><p>Follow dependent links and find the root of this spec&#8217;s DAG.
In spack specs, there should be a single root (the package being
installed).  This will throw an assertion error if that is not
the case.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>other</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.satisfies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.satisfies_dependencies">
<tt class="descname">satisfies_dependencies</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.satisfies_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>This checks constraints on common dependencies against each other.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.short_spec">
<tt class="descname">short_spec</tt><a class="headerlink" href="#spack.spec.Spec.short_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a version of the spec with the dependencies hashed
instead of completely enumerated.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.sorted_deps">
<tt class="descname">sorted_deps</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.sorted_deps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all dependencies sorted by name.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.traverse">
<tt class="descname">traverse</tt><big>(</big><em>visited=None</em>, <em>d=0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.traverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic traversal of the DAG represented by this spec.
This will yield each node in the spec.  Options:</p>
<dl class="docutils">
<dt>order    [=pre|post]</dt>
<dd><p class="first">Order to traverse spec nodes. Defaults to preorder traversal.
Options are:</p>
<dl class="last docutils">
<dt>&#8216;pre&#8217;:  Pre-order traversal; each node is yielded before its</dt>
<dd>children in the dependency DAG.</dd>
<dt>&#8216;post&#8217;: Post-order  traversal; each node is yielded after its</dt>
<dd>children in the dependency DAG.</dd>
</dl>
</dd>
<dt>cover    [=nodes|edges|paths]</dt>
<dd><p class="first">Determines how extensively to cover the dag.  Possible vlaues:</p>
<dl class="last docutils">
<dt>&#8216;nodes&#8217;: Visit each node in the dag only once.  Every node</dt>
<dd>yielded by this function will be unique.</dd>
<dt>&#8216;edges&#8217;: If a node has been visited once but is reached along a</dt>
<dd>new path from the root, yield it but do not descend
into it.  This traverses each &#8216;edge&#8217; in the DAG once.</dd>
<dt>&#8216;paths&#8217;: Explore every unique path reachable from the root.</dt>
<dd>This descends into visited subtrees and will yield
nodes twice if they&#8217;re reachable by multiple paths.</dd>
</dl>
</dd>
<dt>depth    [=False]</dt>
<dd>Defaults to False.  When True, yields not just nodes in the
spec, but also their depth from the root in a (depth, node)
tuple.</dd>
<dt>key   [=id]</dt>
<dd>Allow a custom key function to track the identity of nodes
in the traversal.</dd>
<dt>root     [=True]</dt>
<dd>If false, this won&#8217;t yield the root node, just its descendents.</dd>
<dt>direction [=children|parents]</dt>
<dd>If &#8216;children&#8217;, does a traversal of this spec&#8217;s children.  If
&#8216;parents&#8217;, traverses upwards in the DAG towards the root.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.tree">
<tt class="descname">tree</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints out this spec and its dependencies, tree-formatted
with indentation.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.validate_names">
<tt class="descname">validate_names</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.validate_names" title="Permalink to this definition">¶</a></dt>
<dd><p>This checks that names of packages and compilers in this spec are real.
If they&#8217;re not, it will raise either UnknownPackageError or
UnsupportedCompilerError.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.version">
<tt class="descname">version</tt><a class="headerlink" href="#spack.spec.Spec.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.virtual">
<tt class="descname">virtual</tt><a class="headerlink" href="#spack.spec.Spec.virtual" title="Permalink to this definition">¶</a></dt>
<dd><p>Right now, a spec is virtual if no package exists with its name.</p>
<p>TODO: revisit this &#8211; might need to use a separate namespace and
be more explicit about this.
Possible idea: just use conventin and make virtual deps all
caps, e.g., MPI vs mpi.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.virtual_dependencies">
<tt class="descname">virtual_dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.virtual_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of any virtual deps in this spec.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.spec.SpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">SpecError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.SpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Superclass for all errors that occur while constructing specs.</p>
</dd></dl>

<dl class="class">
<dt id="spack.spec.SpecLexer">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">SpecLexer</tt><a class="headerlink" href="#spack.spec.SpecLexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.parse.Lexer" title="spack.parse.Lexer"><tt class="xref py py-class docutils literal"><span class="pre">spack.parse.Lexer</span></tt></a></p>
<p>Parses tokens that make up spack specs.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.SpecParseError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">SpecParseError</tt><big>(</big><em>parse_error</em><big>)</big><a class="headerlink" href="#spack.spec.SpecParseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Wrapper for ParseError for when we&#8217;re parsing specs.</p>
</dd></dl>

<dl class="class">
<dt id="spack.spec.SpecParser">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">SpecParser</tt><a class="headerlink" href="#spack.spec.SpecParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.parse.Parser" title="spack.parse.Parser"><tt class="xref py py-class docutils literal"><span class="pre">spack.parse.Parser</span></tt></a></p>
<dl class="method">
<dt id="spack.spec.SpecParser.architecture">
<tt class="descname">architecture</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.architecture" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.check_identifier">
<tt class="descname">check_identifier</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.check_identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>The only identifiers that can contain &#8216;.&#8217; are versions, but version
ids are context-sensitive so we have to check on a case-by-case
basis. Call this if we detect a version id where it shouldn&#8217;t be.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.compiler">
<tt class="descname">compiler</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.compiler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.do_parse">
<tt class="descname">do_parse</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.do_parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.parse_compiler">
<tt class="descname">parse_compiler</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.parse_compiler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.spec">
<tt class="descname">spec</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a spec out of the input.  If a spec is supplied, then initialize
and return it instead of creating a new one.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.variant">
<tt class="descname">variant</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.variant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.version">
<tt class="descname">version</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.version_list">
<tt class="descname">version_list</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.version_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableArchitectureSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableArchitectureSpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableArchitectureSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when a spec architecture conflicts with package constraints.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableCompilerSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableCompilerSpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableCompilerSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when a spec comiler conflicts with package constraints.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableDependencySpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableDependencySpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableDependencySpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when some dependency of constrained specs are incompatible</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableProviderSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableProviderSpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableProviderSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when a provider is supplied but constraints don&#8217;t match
a vpkg requirement</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableSpecError</tt><big>(</big><em>provided</em>, <em>required</em>, <em>constraint_type</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when a spec conflicts with package constraints.
Provide the requirement that was violated when raising.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableSpecNameError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableSpecNameError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableSpecNameError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when two specs aren&#8217;t even for the same package.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableVariantSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableVariantSpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableVariantSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when a spec variant conflicts with package constraints.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableVersionSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableVersionSpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableVersionSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when a spec version conflicts with package constraints.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsupportedCompilerError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsupportedCompilerError</tt><big>(</big><em>compiler_name</em><big>)</big><a class="headerlink" href="#spack.spec.UnsupportedCompilerError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when the user asks for a compiler spack doesn&#8217;t know about.</p>
</dd></dl>

<dl class="class">
<dt id="spack.spec.Variant">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">Variant</tt><big>(</big><em>name</em>, <em>enabled</em><big>)</big><a class="headerlink" href="#spack.spec.Variant" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Variants are named, build-time options for a package.  Names depend
on the particular package being built, and each named variant can
be enabled or disabled.</p>
<dl class="method">
<dt id="spack.spec.Variant.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Variant.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.spec.VariantMap">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">VariantMap</tt><a class="headerlink" href="#spack.spec.VariantMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">llnl.util.lang.HashableMap</span></tt></p>
<dl class="method">
<dt id="spack.spec.VariantMap.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.VariantMap.satisfies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="data">
<dt id="spack.spec.color_formats">
<tt class="descclassname">spack.spec.</tt><tt class="descname">color_formats</tt><em class="property"> = {'&#64;': '&#64;c', '%': '&#64;g', '+': '&#64;B', '~': '&#64;r', '=': '&#64;m', '^': '&#64;.'}</em><a class="headerlink" href="#spack.spec.color_formats" title="Permalink to this definition">¶</a></dt>
<dd><p>Regex used for splitting by spec field separators.</p>
</dd></dl>

<dl class="function">
<dt id="spack.spec.colorize_spec">
<tt class="descclassname">spack.spec.</tt><tt class="descname">colorize_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.spec.colorize_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a spec colorized according to the colors specified in
color_formats.</p>
</dd></dl>

<dl class="data">
<dt id="spack.spec.dependency_color">
<tt class="descclassname">spack.spec.</tt><tt class="descname">dependency_color</tt><em class="property"> = '&#64;.'</em><a class="headerlink" href="#spack.spec.dependency_color" title="Permalink to this definition">¶</a></dt>
<dd><p>This map determines the coloring of specs when using color output.
We make the fields different colors to enhance readability.
See spack.color for descriptions of the color codes.</p>
</dd></dl>

<dl class="function">
<dt id="spack.spec.index_specs">
<tt class="descclassname">spack.spec.</tt><tt class="descname">index_specs</tt><big>(</big><em>specs</em><big>)</big><a class="headerlink" href="#spack.spec.index_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a list of specs and return a dict of lists.  Dict is
keyed by spec name and lists include all specs with the
same name.</p>
</dd></dl>

<dl class="function">
<dt id="spack.spec.parse">
<tt class="descclassname">spack.spec.</tt><tt class="descname">parse</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#spack.spec.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of specs from an input string.
For creating one spec, see Spec() constructor.</p>
</dd></dl>

<dl class="function">
<dt id="spack.spec.parse_anonymous_spec">
<tt class="descclassname">spack.spec.</tt><tt class="descname">parse_anonymous_spec</tt><big>(</big><em>spec_like</em>, <em>pkg_name</em><big>)</big><a class="headerlink" href="#spack.spec.parse_anonymous_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the user to omit the package name part of a spec if they
know what it has to be already.</p>
<p>e.g., provides(&#8216;mpi&#64;2&#8217;, <a class="reference external" href="mailto:when='&#37;&#52;&#48;1&#46;9">when='<span>&#64;</span>1<span>&#46;</span>9</a>:&#8217;) says that this package
provides MPI-3 when its version is higher than 1.9.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.stage">
<span id="spack-stage-module"></span><h2>spack.stage module<a class="headerlink" href="#module-spack.stage" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="spack.stage.ChecksumError">
<em class="property">exception </em><tt class="descclassname">spack.stage.</tt><tt class="descname">ChecksumError</tt><big>(</big><em>message</em>, <em>long_msg</em><big>)</big><a class="headerlink" href="#spack.stage.ChecksumError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when archive fails to checksum.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.stage.FailedDownloadError">
<em class="property">exception </em><tt class="descclassname">spack.stage.</tt><tt class="descname">FailedDownloadError</tt><big>(</big><em>url</em>, <em>msg=''</em><big>)</big><a class="headerlink" href="#spack.stage.FailedDownloadError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised wen a download fails.</p>
</dd></dl>

<dl class="class">
<dt id="spack.stage.Stage">
<em class="property">class </em><tt class="descclassname">spack.stage.</tt><tt class="descname">Stage</tt><big>(</big><em>url</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.stage.Stage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A Stage object manaages a directory where an archive is downloaded,
expanded, and built before being installed.  It also handles downloading
the archive.  A stage&#8217;s lifecycle looks like this:</p>
<dl class="docutils">
<dt>Stage()</dt>
<dd>Constructor creates the stage directory.</dd>
<dt>fetch()</dt>
<dd>Fetch a source archive into the stage.</dd>
<dt>expand_archive()</dt>
<dd>Expand the source archive.</dd>
<dt>&lt;install&gt;</dt>
<dd>Build and install the archive.  This is handled by the Package class.</dd>
<dt>destroy()</dt>
<dd>Remove the stage once the package has been installed.</dd>
</dl>
<p>If spack.use_tmp_stage is True, spack will attempt to create stages
in a tmp directory.  Otherwise, stages are created directly in
spack.stage_path.</p>
<p>There are two kinds of stages: named and unnamed.  Named stages can
persist between runs of spack, e.g. if you fetched a tarball but
didn&#8217;t finish building it, you won&#8217;t have to fetch it again.</p>
<p>Unnamed stages are created using standard mkdtemp mechanisms or
similar, and are intended to persist for only one run of spack.</p>
<dl class="attribute">
<dt id="spack.stage.Stage.archive_file">
<tt class="descname">archive_file</tt><a class="headerlink" href="#spack.stage.Stage.archive_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Path to the source archive within this stage directory.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.chdir">
<tt class="descname">chdir</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.chdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes directory to the stage path.  Or dies if it is not set up.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.chdir_to_archive">
<tt class="descname">chdir_to_archive</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.chdir_to_archive" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes directory to the expanded archive directory.
Dies with an error if there was no expanded archive.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.check">
<tt class="descname">check</tt><big>(</big><em>digest</em><big>)</big><a class="headerlink" href="#spack.stage.Stage.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the downloaded archive against a checksum digest</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.destroy">
<tt class="descname">destroy</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this stage directory.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.expand_archive">
<tt class="descname">expand_archive</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.expand_archive" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes to the stage directory and attempt to expand the downloaded
archive.  Fail if the stage is not set up or if the archive is not yet
downloaded.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.stage.Stage.expanded_archive_path">
<tt class="descname">expanded_archive_path</tt><a class="headerlink" href="#spack.stage.Stage.expanded_archive_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the path to the expanded archive directory if it&#8217;s expanded;
None if the archive hasn&#8217;t been expanded.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.fetch">
<tt class="descname">fetch</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Downloads the file at URL to the stage.  Returns true if it was downloaded,
false if it already existed.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.fetch_from_url">
<tt class="descname">fetch_from_url</tt><big>(</big><em>url</em><big>)</big><a class="headerlink" href="#spack.stage.Stage.fetch_from_url" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.restage">
<tt class="descname">restage</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.restage" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the expanded archive path if it exists, then re-expands
the archive.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.stage.ensure_access">
<tt class="descclassname">spack.stage.</tt><tt class="descname">ensure_access</tt><big>(</big><em>file='/Users/gamblin2/src/spack/var/spack/stage'</em><big>)</big><a class="headerlink" href="#spack.stage.ensure_access" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure we can access a directory and die with an error if we can&#8217;t.</p>
</dd></dl>

<dl class="function">
<dt id="spack.stage.find_tmp_root">
<tt class="descclassname">spack.stage.</tt><tt class="descname">find_tmp_root</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.find_tmp_root" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.stage.purge">
<tt class="descclassname">spack.stage.</tt><tt class="descname">purge</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.purge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all build directories in the top-level stage path.</p>
</dd></dl>

<dl class="function">
<dt id="spack.stage.remove_linked_tree">
<tt class="descclassname">spack.stage.</tt><tt class="descname">remove_linked_tree</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.stage.remove_linked_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a directory and its contents.  If the directory is a symlink,
follows the link and reamoves the real directory before removing the
link.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.url">
<span id="spack-url-module"></span><h2>spack.url module<a class="headerlink" href="#module-spack.url" title="Permalink to this headline">¶</a></h2>
<p>This module has methods for parsing names and versions of packages from URLs.
The idea is to allow package creators to supply nothing more than the
download location of the package, and figure out version and name information
from there.</p>
<p>Example: when spack is given the following URL:</p>
<blockquote>
<div><a class="reference external" href="ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.1-p243.tar.gz">ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.1-p243.tar.gz</a></div></blockquote>
<p>It can figure out that the package name is ruby, and that it is at version
1.9.1-p243.  This is useful for making the creation of packages simple: a user
just supplies a URL and skeleton code is generated automatically.</p>
<p>Spack can also figure out that it can most likely download 1.8.1 at this URL:</p>
<blockquote>
<div><a class="reference external" href="ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.8.1.tar.gz">ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.8.1.tar.gz</a></div></blockquote>
<p>This is useful if a user asks for a package at a particular version number;
spack doesn&#8217;t need anyone to tell it where to get the tarball even though
it&#8217;s never been told about that version before.</p>
<dl class="exception">
<dt id="spack.url.UndetectableNameError">
<em class="property">exception </em><tt class="descclassname">spack.url.</tt><tt class="descname">UndetectableNameError</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.UndetectableNameError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.url.UrlParseError" title="spack.url.UrlParseError"><tt class="xref py py-class docutils literal"><span class="pre">spack.url.UrlParseError</span></tt></a></p>
<p>Raised when we can&#8217;t parse a package name from a string.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.url.UndetectableVersionError">
<em class="property">exception </em><tt class="descclassname">spack.url.</tt><tt class="descname">UndetectableVersionError</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.UndetectableVersionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.url.UrlParseError" title="spack.url.UrlParseError"><tt class="xref py py-class docutils literal"><span class="pre">spack.url.UrlParseError</span></tt></a></p>
<p>Raised when we can&#8217;t parse a version from a string.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.url.UrlParseError">
<em class="property">exception </em><tt class="descclassname">spack.url.</tt><tt class="descname">UrlParseError</tt><big>(</big><em>msg</em>, <em>path</em><big>)</big><a class="headerlink" href="#spack.url.UrlParseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when the URL module can&#8217;t parse something correctly.</p>
</dd></dl>

<dl class="function">
<dt id="spack.url.find_list_url">
<tt class="descclassname">spack.url.</tt><tt class="descname">find_list_url</tt><big>(</big><em>url</em><big>)</big><a class="headerlink" href="#spack.url.find_list_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a good list URL for the supplied URL.  This depends on
the site.  By default, just assumes that a good list URL is the
dirname of an archive path.  For github URLs, this returns the
URL of the project&#8217;s releases page.</p>
</dd></dl>

<dl class="function">
<dt id="spack.url.insensitize">
<tt class="descclassname">spack.url.</tt><tt class="descname">insensitize</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#spack.url.insensitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Chagne upper and lowercase letters to be case insensitive in
the provided string.  e.g., &#8216;a&#8217; because &#8216;[Aa]&#8217;, &#8216;B&#8217; becomes
&#8216;[bB]&#8217;, etc.  Use for building regexes.</p>
</dd></dl>

<dl class="function">
<dt id="spack.url.parse_name">
<tt class="descclassname">spack.url.</tt><tt class="descname">parse_name</tt><big>(</big><em>path</em>, <em>ver=None</em><big>)</big><a class="headerlink" href="#spack.url.parse_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.url.parse_name_and_version">
<tt class="descclassname">spack.url.</tt><tt class="descname">parse_name_and_version</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.parse_name_and_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.url.parse_version">
<tt class="descclassname">spack.url.</tt><tt class="descname">parse_version</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.parse_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a URL or archive name, extract a version from it and return
a version object.</p>
</dd></dl>

<dl class="function">
<dt id="spack.url.parse_version_string_with_indices">
<tt class="descclassname">spack.url.</tt><tt class="descname">parse_version_string_with_indices</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.parse_version_string_with_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to extract a version string from a filename or URL.  This is taken
largely from Homebrew&#8217;s Version class.</p>
</dd></dl>

<dl class="function">
<dt id="spack.url.substitute_version">
<tt class="descclassname">spack.url.</tt><tt class="descname">substitute_version</tt><big>(</big><em>path</em>, <em>new_version</em><big>)</big><a class="headerlink" href="#spack.url.substitute_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a URL or archive name, find the version in the path and substitute
the new version for it.</p>
</dd></dl>

<dl class="function">
<dt id="spack.url.wildcard_version">
<tt class="descclassname">spack.url.</tt><tt class="descname">wildcard_version</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.wildcard_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the version in the supplied path, and return a regular expression
that will match this path with any version in its place.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.version">
<span id="spack-version-module"></span><h2>spack.version module<a class="headerlink" href="#module-spack.version" title="Permalink to this headline">¶</a></h2>
<p>This module implements Version and version-ish objects.  These are:</p>
<dl class="docutils">
<dt>Version</dt>
<dd>A single version of a package.</dd>
<dt>VersionRange</dt>
<dd>A range of versions of a package.</dd>
<dt>VersionList</dt>
<dd>A list of Versions and VersionRanges.</dd>
</dl>
<p>All of these types support the following operations, which can
be called on any of the types:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">__eq__</span><span class="p">,</span> <span class="n">__ne__</span><span class="p">,</span> <span class="n">__lt__</span><span class="p">,</span> <span class="n">__gt__</span><span class="p">,</span> <span class="n">__ge__</span><span class="p">,</span> <span class="n">__le__</span><span class="p">,</span> <span class="n">__hash__</span>
<span class="n">__contains__</span>
<span class="n">satisfies</span>
<span class="n">overlaps</span>
<span class="n">union</span>
<span class="n">intersection</span>
<span class="n">concrete</span>
</pre></div>
</div>
<dl class="class">
<dt id="spack.version.Version">
<em class="property">class </em><tt class="descclassname">spack.version.</tt><tt class="descname">Version</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#spack.version.Version" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to represent versions</p>
<dl class="attribute">
<dt id="spack.version.Version.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.version.Version.concrete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.highest">
<tt class="descname">highest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.Version.highest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.intersection">
<tt class="descname">intersection</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.Version.intersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.lowest">
<tt class="descname">lowest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.Version.lowest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.overlaps">
<tt class="descname">overlaps</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.Version.overlaps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.Version.satisfies" title="Permalink to this definition">¶</a></dt>
<dd><p>A Version &#8216;satisfies&#8217; another if it is at least as specific and has a
common prefix.  e.g., we want <a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;7&#46;3">gcc<span>&#64;</span>4<span>&#46;</span>7<span>&#46;</span>3</a> to satisfy a request for
<a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;7">gcc<span>&#64;</span>4<span>&#46;</span>7</a> so that when a user asks to build with <a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;7">gcc<span>&#64;</span>4<span>&#46;</span>7</a>, we can find
a suitable compiler.</p>
</dd></dl>

<dl class="method">
<dt id="spack.version.Version.union">
<tt class="descname">union</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.Version.union" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.up_to">
<tt class="descname">up_to</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#spack.version.Version.up_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version string up to the specified component, exclusive.
e.g., if this is 10.8.2, self.up_to(2) will return &#8216;10.8&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="spack.version.Version.wildcard">
<tt class="descname">wildcard</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.Version.wildcard" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regex that will match variants of this version string.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.version.VersionList">
<em class="property">class </em><tt class="descclassname">spack.version.</tt><tt class="descname">VersionList</tt><big>(</big><em>vlist=None</em><big>)</big><a class="headerlink" href="#spack.version.VersionList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Sorted, non-redundant list of Versions and VersionRanges.</p>
<dl class="method">
<dt id="spack.version.VersionList.add">
<tt class="descname">add</tt><big>(</big><em>version</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.version.VersionList.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.version.VersionList.concrete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.VersionList.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.highest">
<tt class="descname">highest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.VersionList.highest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the highest version in the list.</p>
</dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.intersect">
<tt class="descname">intersect</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.intersect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.intersection">
<tt class="descname">intersection</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.intersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.lowest">
<tt class="descname">lowest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.VersionList.lowest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the lowest version in the list.</p>
</dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.overlaps">
<tt class="descname">overlaps</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.overlaps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.satisfies" title="Permalink to this definition">¶</a></dt>
<dd><p>A VersionList satisfies another if some version in the list would
would satisfy some version in the other list.  This uses essentially
the same algorithm as overlaps() does for VersionList, but it calls
satisfies() on member Versions and VersionRanges.</p>
</dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.union">
<tt class="descname">union</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.union" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.update">
<tt class="descname">update</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.version.VersionRange">
<em class="property">class </em><tt class="descclassname">spack.version.</tt><tt class="descname">VersionRange</tt><big>(</big><em>start</em>, <em>end</em><big>)</big><a class="headerlink" href="#spack.version.VersionRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="attribute">
<dt id="spack.version.VersionRange.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.version.VersionRange.concrete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.highest">
<tt class="descname">highest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.VersionRange.highest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.intersection">
<tt class="descname">intersection</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionRange.intersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.lowest">
<tt class="descname">lowest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.VersionRange.lowest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.overlaps">
<tt class="descname">overlaps</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionRange.overlaps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionRange.satisfies" title="Permalink to this definition">¶</a></dt>
<dd><p>A VersionRange satisfies another if some version in this range
would satisfy some version in the other range.  To do this it must
either:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>Overlap with the other range</li>
<li>The start of this range satisfies the end of the other range.</li>
</ol>
</div></blockquote>
<p>This is essentially the same as overlaps(), but overlaps assumes
that its arguments are specific.  That is, 4.7 is interpreted as
4.7.0.0.0.0... .  This funciton assumes that 4.7 woudl be satisfied
by 4.7.3.5, etc.</p>
<p>Rationale:
If a user asks for <a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;5">gcc<span>&#64;</span>4<span>&#46;</span>5</a>:4.7, and a package is only compatible with
<a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;7&#46;3">gcc<span>&#64;</span>4<span>&#46;</span>7<span>&#46;</span>3</a>:4.8, then that package should be able to build under the
constraints.  Just using overlaps() would not work here.</p>
<p>Note that we don&#8217;t need to check whether the end of this range
would satisfy the start of the other range, because overlaps()
already covers that case.</p>
<p>Note further that overlaps() is a symmetric operation, while
satisfies() is not.</p>
</dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.union">
<tt class="descname">union</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionRange.union" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.version.coerce_versions">
<tt class="descclassname">spack.version.</tt><tt class="descname">coerce_versions</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.coerce_versions" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Convert both a and b to the &#8216;greatest&#8217; type between them, in this order:</dt>
<dd>Version &lt; VersionRange &lt; VersionList</dd>
</dl>
<p>This is used to simplify comparison operations below so that we&#8217;re always
comparing things that are of the same type.</p>
</dd></dl>

<dl class="function">
<dt id="spack.version.coerced">
<tt class="descclassname">spack.version.</tt><tt class="descname">coerced</tt><big>(</big><em>method</em><big>)</big><a class="headerlink" href="#spack.version.coerced" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator that ensures that argument types of a method are coerced.</p>
</dd></dl>

<dl class="function">
<dt id="spack.version.int_if_int">
<tt class="descclassname">spack.version.</tt><tt class="descname">int_if_int</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#spack.version.int_if_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string to int if possible.  Otherwise, return a string.</p>
</dd></dl>

<dl class="function">
<dt id="spack.version.ver">
<tt class="descclassname">spack.version.</tt><tt class="descname">ver</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#spack.version.ver" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a Version, VersionRange, or VersionList from a string
or list of strings.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.virtual">
<span id="spack-virtual-module"></span><h2>spack.virtual module<a class="headerlink" href="#module-spack.virtual" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">virtual</span></tt> module contains utility classes for virtual dependencies.</p>
<dl class="class">
<dt id="spack.virtual.ProviderIndex">
<em class="property">class </em><tt class="descclassname">spack.virtual.</tt><tt class="descname">ProviderIndex</tt><big>(</big><em>specs</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.virtual.ProviderIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is a dict of dicts used for finding providers of particular
virtual dependencies. The dict of dicts looks like:</p>
<dl class="docutils">
<dt>{ vpkg name :</dt>
<dd>{ full vpkg spec : package providing spec } }</dd>
</dl>
<p>Callers can use this to first find which packages provide a vpkg,
then find a matching full spec.  e.g., in this scenario:</p>
<dl class="docutils">
<dt>{ &#8216;mpi&#8217; :</dt>
<dd><dl class="first last docutils">
<dt>{ mpi&#64;:1.1 <span class="classifier-delimiter">:</span> <span class="classifier">mpich,</span></dt>
<dd>mpi&#64;:2.3 : <a class="reference external" href="mailto:mpich2&#37;&#52;&#48;1&#46;9">mpich2<span>&#64;</span>1<span>&#46;</span>9</a>: } }</dd>
</dl>
</dd>
</dl>
<p>Calling providers_for(spec) will find specs that provide a
matching implementation of MPI.</p>
<dl class="method">
<dt id="spack.virtual.ProviderIndex.providers_for">
<tt class="descname">providers_for</tt><big>(</big><em>*vpkg_specs</em><big>)</big><a class="headerlink" href="#spack.virtual.ProviderIndex.providers_for" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives specs of all packages that provide virtual packages
with the supplied specs.</p>
</dd></dl>

<dl class="method">
<dt id="spack.virtual.ProviderIndex.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.virtual.ProviderIndex.satisfies" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that providers of virtual specs are compatible.</p>
</dd></dl>

<dl class="method">
<dt id="spack.virtual.ProviderIndex.update">
<tt class="descname">update</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.virtual.ProviderIndex.update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-spack">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-spack" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="spack.Package">
<em class="property">class </em><tt class="descclassname">spack.</tt><tt class="descname">Package</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.Package" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is the superclass for all spack packages.</p>
<p><strong>*The Package class*</strong></p>
<p>Package is where the bulk of the work of installing packages is done.</p>
<p>A package defines how to fetch, verfiy (via, e.g., md5), build, and
install a piece of software.  A Package also defines what other
packages it depends on, so that dependencies can be installed along
with the package itself.  Packages are written in pure python.</p>
<p>Packages are all submodules of spack.packages.  If spack is installed
in $prefix, all of its python files are in $prefix/lib/spack.  Most
of them are in the spack module, so all the packages live in
$prefix/lib/spack/spack/packages.</p>
<p>All you have to do to create a package is make a new subclass of Package
in this directory.  Spack automatically scans the python files there
and figures out which one to import when you invoke it.</p>
<p><strong>An example package</strong></p>
<p>Let&#8217;s look at the cmake package to start with.  This package lives in
$prefix/lib/spack/spack/packages/cmake.py:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">spack</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">class</span> <span class="nc">Cmake</span><span class="p">(</span><span class="n">Package</span><span class="p">):</span>
    <span class="n">homepage</span>  <span class="o">=</span> <span class="s">&#39;https://www.cmake.org&#39;</span>
    <span class="n">url</span>       <span class="o">=</span> <span class="s">&#39;http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz&#39;</span>
    <span class="n">md5</span>       <span class="o">=</span> <span class="s">&#39;097278785da7182ec0aea8769d06860c&#39;</span>

    <span class="k">def</span> <span class="nf">install</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="n">configure</span><span class="p">(</span><span class="s">&#39;--prefix=</span><span class="si">%s</span><span class="s">&#39;</span>   <span class="o">%</span> <span class="n">prefix</span><span class="p">,</span>
                  <span class="s">&#39;--parallel=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">make_jobs</span><span class="p">)</span>
        <span class="n">make</span><span class="p">()</span>
        <span class="n">make</span><span class="p">(</span><span class="s">&#39;install&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Naming conventions</strong></p>
<p>There are two names you should care about:</p>
<ol class="arabic">
<li><p class="first">The module name, <tt class="docutils literal"><span class="pre">cmake</span></tt>.</p>
<ul class="simple">
<li>User will refers to this name, e.g. &#8216;spack install cmake&#8217;.</li>
<li>Corresponds to the name of the file, &#8216;cmake.py&#8217;, and it can
include <tt class="docutils literal"><span class="pre">_</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, and numbers (it can even start with a
number).</li>
</ul>
</li>
<li><p class="first">The class name, &#8220;Cmake&#8221;.  This is formed by converting <cite>-</cite> or
<tt class="docutils literal"><span class="pre">_</span></tt> in the module name to camel case.  If the name starts with
a number, we prefix the class name with <tt class="docutils literal"><span class="pre">Num_</span></tt>. Examples:</p>
<blockquote>
<div><blockquote>
<div><dl class="docutils">
<dt>Module Name       Class Name</dt>
<dd><p class="first last">foo_bar           FooBar
docbook-xml       DocbookXml
FooBar            Foobar
3proxy            Num_3proxy</p>
</dd>
</dl>
</div></blockquote>
<p>The class name is what spack looks for when it loads a package module.</p>
</div></blockquote>
</li>
</ol>
<p><strong>Required Attributes</strong></p>
<p>Aside from proper naming, here is the bare minimum set of things you
need when you make a package:</p>
<dl class="docutils">
<dt>homepage</dt>
<dd>informational URL, so that users know what they&#8217;re
installing.</dd>
<dt>url</dt>
<dd>URL of the source archive that spack will fetch.</dd>
<dt>install()</dt>
<dd>This function tells spack how to build and install the
software it downloaded.</dd>
</dl>
<p><strong>Optional Attributes</strong></p>
<p>You can also optionally add these attributes, if needed:</p>
<blockquote>
<div><dl class="docutils">
<dt>list_url</dt>
<dd>Webpage to scrape for available version strings. Default is the
directory containing the tarball; use this if the default isn&#8217;t
correct so that invoking &#8216;spack versions&#8217; will work for this
package.</dd>
<dt>url_version(self, version)</dt>
<dd>When spack downloads packages at particular versions, it just
converts version to string with str(version).  Override this if
your package needs special version formatting in its URL.  boost
is an example of a package that needs this.</dd>
</dl>
</div></blockquote>
<p><strong>*Creating Packages*</strong></p>
<p>As a package creator, you can probably ignore most of the preceding
information, because you can use the &#8216;spack create&#8217; command to do it
all automatically.</p>
<p>You as the package creator generally only have to worry about writing
your install function and specifying dependencies.</p>
<p><strong>spack create</strong></p>
<dl class="docutils">
<dt>Most software comes in nicely packaged tarballs, like this one:</dt>
<dd><a class="reference external" href="http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz">http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz</a></dd>
</dl>
<p>Taking a page from homebrew, spack deduces pretty much everything it
needs to know from the URL above.  If you simply type this:</p>
<blockquote>
<div>spack create <a class="reference external" href="http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz">http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz</a></div></blockquote>
<p>Spack will download the tarball, generate an md5 hash, figure out the
version and the name of the package from the URL, and create a new
package file for you with all the names and attributes set correctly.</p>
<p>Once this skeleton code is generated, spack pops up the new package in
your $EDITOR so that you can modify the parts that need changes.</p>
<p><strong>Dependencies</strong></p>
<p>If your package requires another in order to build, you can specify that
like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Stackwalker</span><span class="p">(</span><span class="n">Package</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">depends_on</span><span class="p">(</span><span class="s">&quot;libdwarf&quot;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This tells spack that before it builds stackwalker, it needs to build
the libdwarf package as well.  Note that this is the module name, not
the class name (The class name is really only used by spack to find
your package).</p>
<p>Spack will download an install each dependency before it installs your
package.  In addtion, it will add -L, -I, and rpath arguments to your
compiler and linker for each dependency.  In most cases, this allows you
to avoid specifying any dependencies in your configure or cmake line;
you can just run configure or cmake without any additional arguments and
it will find the dependencies automatically.</p>
<p><strong>The Install Function</strong></p>
<p>The install function is designed so that someone not too terribly familiar
with Python could write a package installer.  For example, we put a number
of commands in install scope that you can use almost like shell commands.
These include make, configure, cmake, rm, rmtree, mkdir, mkdirp, and others.</p>
<p>You can see above in the cmake script that these commands are used to run
configure and make almost like they&#8217;re used on the command line.  The
only difference is that they are python function calls and not shell
commands.</p>
<p>It may be puzzling to you where the commands and functions in install live.
They are NOT instance variables on the class; this would require us to
type &#8216;self.&#8217; all the time and it makes the install code unnecessarily long.
Rather, spack puts these commands and variables in <em>module</em> scope for your
Package subclass.  Since each package has its own module, this doesn&#8217;t
pollute other namespaces, and it allows you to more easily implement an
install function.</p>
<p>For a full list of commands and variables available in module scope, see the
add_commands_to_module() function in this class. This is where most of
them are created and set on the module.</p>
<p><strong>Parallel Builds</strong></p>
<p>By default, Spack will run make in parallel when you run make() in your
install function.  Spack figures out how many cores are available on
your system and runs make with -j&lt;cores&gt;.  If you do not want this behavior,
you can explicitly mark a package not to use parallel make:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SomePackage</span><span class="p">(</span><span class="n">Package</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">parallel</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This changes thd default behavior so that make is sequential.  If you still
want to build some parts in parallel, you can do this in your install function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">make</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Likewise, if you do not supply parallel = True in your Package, you can keep
the default parallel behavior and run make like this when you want a
sequential build:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">make</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Package Lifecycle</strong></p>
<p>This section is really only for developers of new spack commands.</p>
<p>A package&#8217;s lifecycle over a run of Spack looks something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Package</span><span class="p">()</span>             <span class="c"># Done for you by spack</span>

<span class="n">p</span><span class="o">.</span><span class="n">do_fetch</span><span class="p">()</span>              <span class="c"># downloads tarball from a URL</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_stage</span><span class="p">()</span>              <span class="c"># expands tarball in a temp directory</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_patch</span><span class="p">()</span>              <span class="c"># applies patches to expanded source</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_install</span><span class="p">()</span>            <span class="c"># calls package&#39;s install() function</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_uninstall</span><span class="p">()</span>          <span class="c"># removes install directory</span>
</pre></div>
</div>
<p>There are also some other commands that clean the build area:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span><span class="o">.</span><span class="n">do_clean</span><span class="p">()</span>              <span class="c"># runs make clean</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_clean_work</span><span class="p">()</span>         <span class="c"># removes the build directory and</span>
                          <span class="c"># re-expands the archive.</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_clean_dist</span><span class="p">()</span>         <span class="c"># removes the stage directory entirely</span>
</pre></div>
</div>
<p>The convention used here is that a do_* function is intended to be called
internally by Spack commands (in spack.cmd).  These aren&#8217;t for package
writers to override, and doing so may break the functionality of the Package
class.</p>
<p>Package creators override functions like install() (all of them do this),
clean() (some of them do this), and others to provide custom behavior.</p>
<dl class="attribute">
<dt id="spack.Package.available_versions">
<tt class="descname">available_versions</tt><a class="headerlink" href="#spack.Package.available_versions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Package.clean">
<tt class="descname">clean</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>By default just runs make clean.  Override if this isn&#8217;t good.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.Package.compiler">
<tt class="descname">compiler</tt><a class="headerlink" href="#spack.Package.compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the spack.compiler.Compiler object used to build this package.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.Package.conflicted">
<tt class="descname">conflicted</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.Package.conflicted" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.Package.default_url">
<tt class="descname">default_url</tt><a class="headerlink" href="#spack.Package.default_url" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.Package.dependencies">
<tt class="descname">dependencies</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.Package.dependencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Package.do_clean">
<tt class="descname">do_clean</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.do_clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Package.do_clean_dist">
<tt class="descname">do_clean_dist</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.do_clean_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the stage directory where this package was built.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Package.do_clean_work">
<tt class="descname">do_clean_work</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.do_clean_work" title="Permalink to this definition">¶</a></dt>
<dd><p>By default just blows away the stage directory and re-stages.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Package.do_fetch">
<tt class="descname">do_fetch</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.do_fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a stage directory and downloads the taball for this package.
Working directory will be set to the stage directory.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Package.do_install">
<tt class="descname">do_install</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.Package.do_install" title="Permalink to this definition">¶</a></dt>
<dd><p>This class should call this version of the install method.
Package implementations should override install().</p>
</dd></dl>

<dl class="method">
<dt id="spack.Package.do_install_dependencies">
<tt class="descname">do_install_dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.do_install_dependencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Package.do_patch">
<tt class="descname">do_patch</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.do_patch" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls do_stage(), then applied patches to the expanded tarball if they
haven&#8217;t been applied already.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Package.do_stage">
<tt class="descname">do_stage</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.do_stage" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpacks the fetched tarball, then changes into the expanded tarball
directory.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Package.do_uninstall">
<tt class="descname">do_uninstall</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.Package.do_uninstall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Package.fetch_available_versions">
<tt class="descname">fetch_available_versions</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.fetch_available_versions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Package.install">
<tt class="descname">install</tt><big>(</big><em>spec</em>, <em>prefix</em><big>)</big><a class="headerlink" href="#spack.Package.install" title="Permalink to this definition">¶</a></dt>
<dd><p>Package implementations override this with their own build configuration.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.Package.installed">
<tt class="descname">installed</tt><a class="headerlink" href="#spack.Package.installed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.Package.installed_dependents">
<tt class="descname">installed_dependents</tt><a class="headerlink" href="#spack.Package.installed_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the specs of all installed packages that depend
on this one.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.Package.module">
<tt class="descname">module</tt><a class="headerlink" href="#spack.Package.module" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this to add variables to the class&#8217;s module&#8217;s scope.
This lets us use custom syntax in the install method.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.Package.parallel">
<tt class="descname">parallel</tt><em class="property"> = True</em><a class="headerlink" href="#spack.Package.parallel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.Package.patches">
<tt class="descname">patches</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.Package.patches" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.Package.prefix">
<tt class="descname">prefix</tt><a class="headerlink" href="#spack.Package.prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the prefix into which this package should be installed.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Package.preorder_traversal">
<tt class="descname">preorder_traversal</tt><big>(</big><em>visited=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.Package.preorder_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>This does a preorder traversal of the package&#8217;s dependence DAG.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.Package.provided">
<tt class="descname">provided</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.Package.provided" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Package.provides">
<tt class="descname">provides</tt><big>(</big><em>vpkg_name</em><big>)</big><a class="headerlink" href="#spack.Package.provides" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this package provides a virtual package with the specified name.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Package.remove_prefix">
<tt class="descname">remove_prefix</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.remove_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the prefix for a package along with any empty parent directories.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.Package.stage">
<tt class="descname">stage</tt><a class="headerlink" href="#spack.Package.stage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Package.url_for_version">
<tt class="descname">url_for_version</tt><big>(</big><em>version</em><big>)</big><a class="headerlink" href="#spack.Package.url_for_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a URL that you can download a new version of this package from.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Package.url_version">
<tt class="descname">url_version</tt><big>(</big><em>version</em><big>)</big><a class="headerlink" href="#spack.Package.url_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a version, this returns a string that should be substituted into the
package&#8217;s URL to download that version.
By default, this just returns the version string. Subclasses may need to
override this, e.g. for boost versions where you need to ensure that there
are _&#8217;s in the download URL.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Package.validate_dependencies">
<tt class="descname">validate_dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Package.validate_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that this package and its dependencies all have consistent
constraints on them.</p>
<p>NOTE that this will NOT find sanity problems through a virtual
dependency.  Virtual deps complicate the problem because we
don&#8217;t know in advance which ones conflict with others in the
dependency DAG. If there&#8217;s more than one virtual dependency,
it&#8217;s a full-on SAT problem, so hold off on this for now.
The vdeps are actually skipped in preorder_traversal, so see
that for details.</p>
<p>TODO: investigate validating virtual dependencies.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.Package.version">
<tt class="descname">version</tt><a class="headerlink" href="#spack.Package.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.Package.versions">
<tt class="descname">versions</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.Package.versions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Package.virtual_dependencies">
<tt class="descname">virtual_dependencies</tt><big>(</big><em>visited=None</em><big>)</big><a class="headerlink" href="#spack.Package.virtual_dependencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.Version">
<em class="property">class </em><tt class="descclassname">spack.</tt><tt class="descname">Version</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#spack.Version" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to represent versions</p>
<dl class="attribute">
<dt id="spack.Version.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.Version.concrete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Version.highest">
<tt class="descname">highest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Version.highest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Version.intersection">
<tt class="descname">intersection</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.Version.intersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Version.lowest">
<tt class="descname">lowest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Version.lowest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Version.overlaps">
<tt class="descname">overlaps</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.Version.overlaps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Version.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.Version.satisfies" title="Permalink to this definition">¶</a></dt>
<dd><p>A Version &#8216;satisfies&#8217; another if it is at least as specific and has a
common prefix.  e.g., we want <a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;7&#46;3">gcc<span>&#64;</span>4<span>&#46;</span>7<span>&#46;</span>3</a> to satisfy a request for
<a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;7">gcc<span>&#64;</span>4<span>&#46;</span>7</a> so that when a user asks to build with <a class="reference external" href="mailto:gcc&#37;&#52;&#48;4&#46;7">gcc<span>&#64;</span>4<span>&#46;</span>7</a>, we can find
a suitable compiler.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Version.union">
<tt class="descname">union</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.Version.union" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.Version.up_to">
<tt class="descname">up_to</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#spack.Version.up_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version string up to the specified component, exclusive.
e.g., if this is 10.8.2, self.up_to(2) will return &#8216;10.8&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="spack.Version.wildcard">
<tt class="descname">wildcard</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.Version.wildcard" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regex that will match variants of this version string.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.when">
<em class="property">class </em><tt class="descclassname">spack.</tt><tt class="descname">when</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.when" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="spack.ver">
<tt class="descclassname">spack.</tt><tt class="descname">ver</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#spack.ver" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a Version, VersionRange, or VersionList from a string
or list of strings.</p>
</dd></dl>

<dl class="function">
<dt id="spack.install">
<tt class="descclassname">spack.</tt><tt class="descname">install</tt><big>(</big><em>src</em>, <em>dest</em><big>)</big><a class="headerlink" href="#spack.install" title="Permalink to this definition">¶</a></dt>
<dd><p>Manually install a file to a particular location.</p>
</dd></dl>

<dl class="function">
<dt id="spack.expand_user">
<tt class="descclassname">spack.</tt><tt class="descname">expand_user</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.expand_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Find instances of &#8216;%u&#8217; in a path and replace with the current user&#8217;s
username.</p>
</dd></dl>

<dl class="function">
<dt id="spack.working_dir">
<tt class="descclassname">spack.</tt><tt class="descname">working_dir</tt><big>(</big><em>*args</em>, <em>**kwds</em><big>)</big><a class="headerlink" href="#spack.working_dir" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.touch">
<tt class="descclassname">spack.</tt><tt class="descname">touch</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.touch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.mkdirp">
<tt class="descclassname">spack.</tt><tt class="descname">mkdirp</tt><big>(</big><em>*paths</em><big>)</big><a class="headerlink" href="#spack.mkdirp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.join_path">
<tt class="descclassname">spack.</tt><tt class="descname">join_path</tt><big>(</big><em>prefix</em>, <em>*args</em><big>)</big><a class="headerlink" href="#spack.join_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.ancestor">
<tt class="descclassname">spack.</tt><tt class="descname">ancestor</tt><big>(</big><em>dir</em>, <em>n=1</em><big>)</big><a class="headerlink" href="#spack.ancestor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nth ancestor of a directory.</p>
</dd></dl>

<dl class="function">
<dt id="spack.can_access">
<tt class="descclassname">spack.</tt><tt class="descname">can_access</tt><big>(</big><em>file_name</em><big>)</big><a class="headerlink" href="#spack.can_access" title="Permalink to this definition">¶</a></dt>
<dd><p>True if we have read/write access to the file.</p>
</dd></dl>

<dl class="function">
<dt id="spack.filter_file">
<tt class="descclassname">spack.</tt><tt class="descname">filter_file</tt><big>(</big><em>regex</em>, <em>repl</em>, <em>*filenames</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.filter_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Like sed, but uses python regular expressions.</p>
<p>Filters every line of file through regex and replaces the file
with a filtered version.  Preserves mode of filtered files.</p>
<p>As with re.sub, <tt class="docutils literal"><span class="pre">repl</span></tt> can be either a string or a callable.
If it is a callable, it is passed the match object and should
return a suitable replacement string.  If it is a string, it
can contain <tt class="docutils literal"><span class="pre"></span></tt>, <tt class="docutils literal"><span class="pre"></span></tt>, etc. to represent back-substitution
as sed would allow.</p>
<dl class="docutils">
<dt>Keyword Options:</dt>
<dd>string[=False]         If True, treat regex as a plain string.
backup[=True]          Make a backup files suffixed with ~
ignore_absent[=False]  Ignore any files that don&#8217;t exist.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="spack.change_sed_delimiter">
<tt class="descclassname">spack.</tt><tt class="descname">change_sed_delimiter</tt><big>(</big><em>old_delim</em>, <em>new_delim</em>, <em>*filenames</em><big>)</big><a class="headerlink" href="#spack.change_sed_delimiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all sed search/replace commands and change the delimiter.
e.g., if the file contains seds that look like &#8216;s///&#8217;, you can
call change_sed_delimeter(&#8216;/&#8217;, &#8216;&#64;&#8217;, file) to change the
delimiter to &#8216;&#64;&#8217;.</p>
<p>NOTE that this routine will fail if the delimiter is &#8216; or &#8221;.
Handling those is left for future work.</p>
</dd></dl>

<dl class="function">
<dt id="spack.depends_on">
<tt class="descclassname">spack.</tt><tt class="descname">depends_on</tt><big>(</big><em>*specs</em><big>)</big><a class="headerlink" href="#spack.depends_on" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a dependencies local variable in the locals of
the calling class, based on args.</p>
</dd></dl>

<dl class="function">
<dt id="spack.provides">
<tt class="descclassname">spack.</tt><tt class="descname">provides</tt><big>(</big><em>*specs</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.provides" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows packages to provide a virtual dependency.  If a package provides
&#8216;mpi&#8217;, other packages can declare that they depend on &#8220;mpi&#8221;, and spack
can use the providing package to satisfy the dependency.</p>
</dd></dl>

<dl class="function">
<dt id="spack.patch">
<tt class="descclassname">spack.</tt><tt class="descname">patch</tt><big>(</big><em>url_or_filename</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.patch" title="Permalink to this definition">¶</a></dt>
<dd><p>Packages can declare patches to apply to source.  You can
optionally provide a when spec to indicate that a particular
patch should only be applied when the package&#8217;s spec meets
certain conditions (e.g. a particular version).</p>
</dd></dl>

<dl class="function">
<dt id="spack.version">
<tt class="descclassname">spack.</tt><tt class="descname">version</tt><big>(</big><em>ver</em>, <em>checksum</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.version" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a version and associated metadata to the package.</p>
</dd></dl>

<dl class="class">
<dt id="spack.Executable">
<em class="property">class </em><tt class="descclassname">spack.</tt><tt class="descname">Executable</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#spack.Executable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class representing a program that can be run on the command line.</p>
<dl class="method">
<dt id="spack.Executable.add_default_arg">
<tt class="descname">add_default_arg</tt><big>(</big><em>arg</em><big>)</big><a class="headerlink" href="#spack.Executable.add_default_arg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.Executable.command">
<tt class="descname">command</tt><a class="headerlink" href="#spack.Executable.command" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.which">
<tt class="descclassname">spack.</tt><tt class="descname">which</tt><big>(</big><em>name</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.which" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds an executable in the path like command-line which.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.ProcessError">
<em class="property">exception </em><tt class="descclassname">spack.</tt><tt class="descname">ProcessError</tt><big>(</big><em>msg</em>, <em>*long_msg</em><big>)</big><a class="headerlink" href="#spack.ProcessError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
</dd></dl>

</div>
</div>


          <footer>
  
    <div class="rst-footer-buttons">
      
        <a href="spack.cmd.html" class="btn btn-neutral float-right" title="spack.cmd package"/>Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="package_list.html" class="btn btn-neutral" title="Package List"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <p>
    &copy; Copyright 2013-2014,
    <a href="https://scalability.llnl.gov/">Lawrence Livermore National Laboratory</a>.
    <br/>
    Written by Todd Gamblin, <a href="mailto:tgamblin@llnl.gov">tgamblin@llnl.gov</a>, LLNL-CODE-647188
    <br/>
    Last updated on Oct 08, 2014.
  &nbsp;&nbsp;
  <br/><a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://readthedocs.org">Read the Docs</a>
  </p>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>